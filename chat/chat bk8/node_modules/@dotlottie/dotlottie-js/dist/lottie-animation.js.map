{"version":3,"sources":["../src/common/dotlottie-state-machine-common.ts","../src/common/dotlottie-state.ts","../src/common/manifest.ts","../src/common/utils.ts","../src/common/lottie-animation-common.ts","../src/common/lottie-image-common.ts","../src/lottie-image.ts","../src/common/lottie-audio-common.ts","../src/node/lottie-audio.ts","../src/lottie-animation.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2023 Design Barn Inc.\n */\n\nimport type { ZipOptions } from 'fflate';\nimport { safeParse, flatten } from 'valibot';\n\nimport {\n  DotLottieStatesSchema,\n  type DotLottieStates,\n  type DotLottieStateMachineDescriptor,\n  DotLottieStateMachineDescriptorSchema,\n} from './dotlottie-state';\nimport { DotLottieError, ErrorCodes, createError } from './utils';\n\nexport interface DotLottieStateMachineCommonOptions {\n  descriptor: DotLottieStateMachineDescriptor;\n  states: DotLottieStates;\n  zipOptions?: ZipOptions;\n}\n\nexport class DotLottieStateMachineCommon {\n  protected _descriptor: DotLottieStateMachineDescriptor;\n\n  protected _zipOptions: ZipOptions;\n\n  protected _states: DotLottieStates;\n\n  public constructor(options: DotLottieStateMachineCommonOptions) {\n    this._requireValidId(options.descriptor.id);\n    this._requireValidStates(options.states);\n    this._requireValidDescriptor(options.descriptor);\n\n    this._descriptor = options.descriptor;\n\n    this._zipOptions = options.zipOptions ?? {};\n\n    this._states = options.states;\n  }\n\n  public get zipOptions(): ZipOptions {\n    return this._zipOptions;\n  }\n\n  public set zipOptions(zipOptions: ZipOptions) {\n    this._zipOptions = zipOptions;\n  }\n\n  public get id(): string {\n    return this._descriptor.id;\n  }\n\n  public set id(id: string) {\n    this._requireValidId(id);\n\n    this._descriptor.id = id;\n  }\n\n  public get states(): DotLottieStates {\n    return this._states;\n  }\n\n  public set states(states: DotLottieStates) {\n    this._states = states;\n  }\n\n  public get initial(): string {\n    return this._descriptor.initial;\n  }\n\n  public set initial(initial: string) {\n    this._descriptor.initial = initial;\n  }\n\n  public get descriptor(): DotLottieStateMachineDescriptor {\n    return this._descriptor;\n  }\n\n  public set descriptor(descriptor: DotLottieStateMachineDescriptor) {\n    this._descriptor = descriptor;\n  }\n\n  public toString(): string {\n    return JSON.stringify({\n      descriptor: this._descriptor,\n      states: this._states,\n    });\n  }\n\n  protected _requireValidId(id: string | undefined): void {\n    if (!id) {\n      throw createError('Invalid id.');\n    }\n  }\n\n  protected _requireValidDescriptor(descriptor: DotLottieStateMachineDescriptor): void {\n    const result = safeParse(DotLottieStateMachineDescriptorSchema, descriptor);\n\n    if (!result.success) {\n      const error = `Invalid state machine declaration, ${JSON.stringify(flatten(result.error).nested, null, 2)}`;\n\n      throw new DotLottieError(`Invalid descriptor: ${error}`, ErrorCodes.INVALID_STATEMACHINE);\n    }\n  }\n\n  protected _requireValidStates(states: DotLottieStates): void {\n    const result = safeParse(DotLottieStatesSchema, states);\n\n    if (!result.success) {\n      const error = `Invalid state machine declaration, ${JSON.stringify(flatten(result.error).nested, null, 2)}`;\n\n      throw new DotLottieError(`Invalid states: ${error}`, ErrorCodes.INVALID_STATEMACHINE);\n    }\n  }\n}\n","/**\n * Copyright 2023 Design Barn Inc.\n */\n\nimport type { Output } from 'valibot';\nimport {\n  merge,\n  number,\n  object,\n  optional,\n  string,\n  union,\n  omit,\n  record,\n  tuple,\n  maxValue,\n  minValue,\n  array,\n} from 'valibot';\n\nimport { ManifestAnimationSchema } from './manifest';\n\nexport const PlaybackOptionsSchema = omit(ManifestAnimationSchema, ['id']);\n\nexport type PlaybackOptions = Output<typeof PlaybackOptionsSchema>;\n\nexport const TransitionableSchema = object({\n  state: string(),\n});\nexport type Transitionable = Output<typeof TransitionableSchema>;\n\nexport const StateTransitionOnClickSchema = TransitionableSchema;\n\nexport type StateTransitionOnClick = Output<typeof StateTransitionOnClickSchema>;\n\nexport const StateTransitionOnAfterSchema = merge([TransitionableSchema, object({ ms: number() })]);\n\nexport type StateTransitionOnAfter = Output<typeof StateTransitionOnAfterSchema>;\n\nexport const StateTransitionOnEnterSchema = merge([TransitionableSchema, object({ count: number() })]);\n\nexport type StateTransitionOnEnter = Output<typeof StateTransitionOnEnterSchema>;\n\nexport const StateTransitionOnMouseEnterSchema = TransitionableSchema;\n\nexport type StateTransitionOnMouseEnter = Output<typeof StateTransitionOnMouseEnterSchema>;\n\nexport const StateTransitionOnMouseLeaveSchema = TransitionableSchema;\n\nexport type StateTransitionOnMouseLeave = Output<typeof StateTransitionOnMouseLeaveSchema>;\n\nexport const StateTransitionOnCompleteSchema = TransitionableSchema;\n\nexport type StateTransitionOnComplete = Output<typeof StateTransitionOnCompleteSchema>;\n\nexport const StateTransitionOnShowSchema = merge([\n  TransitionableSchema,\n  object({ threshold: optional(array(number([minValue(0), maxValue(1)]))) }),\n]);\nexport type StateTransitionOnShow = Output<typeof StateTransitionOnShowSchema>;\n\nexport const DotLottieStateTransitionEventsSchema = object({\n  onAfter: optional(StateTransitionOnAfterSchema),\n  onClick: optional(StateTransitionOnClickSchema),\n  onComplete: optional(StateTransitionOnCompleteSchema),\n  onEnter: optional(StateTransitionOnEnterSchema),\n  onMouseEnter: optional(StateTransitionOnMouseEnterSchema),\n  onMouseLeave: optional(StateTransitionOnMouseLeaveSchema),\n  onShow: optional(StateTransitionOnShowSchema),\n});\nexport type DotLottieStateTransitionEvents = Output<typeof DotLottieStateTransitionEventsSchema>;\n\nexport const DotLottieStatePlaybackSettingsSchema = merge([\n  PlaybackOptionsSchema,\n  object({\n    playOnScroll: optional(tuple([number([minValue(0), maxValue(1)]), number([minValue(0), maxValue(1)])])),\n    segments: optional(union([tuple([number(), number()]), string()])),\n  }),\n]);\nexport type DotLottieStatePlaybackSettings = Output<typeof DotLottieStatePlaybackSettingsSchema>;\n\nexport const DotLottieStateSchema = merge([\n  DotLottieStateTransitionEventsSchema,\n  object({\n    animationId: optional(string()),\n    playbackSettings: DotLottieStatePlaybackSettingsSchema,\n  }),\n]);\nexport type DotLottieState = Output<typeof DotLottieStateSchema>;\n\nexport const DotLottieStatesSchema = record(string(), DotLottieStateSchema);\nexport type DotLottieStates = Output<typeof DotLottieStatesSchema>;\n\nexport const DotLottieStateMachineDescriptorSchema = object({\n  id: string(),\n  initial: string(),\n});\nexport type DotLottieStateMachineDescriptor = Output<typeof DotLottieStateMachineDescriptorSchema>;\n\nexport const DotLottieStateMachineSchema = object({\n  descriptor: DotLottieStateMachineDescriptorSchema,\n  states: DotLottieStatesSchema,\n});\nexport type DotLottieStateMachine = Output<typeof DotLottieStateMachineSchema>;\n","/**\n * Copyright 2023 Design Barn Inc.\n */\n\nimport {\n  object,\n  type Output,\n  string,\n  array,\n  boolean,\n  number,\n  union,\n  optional,\n  record,\n  any,\n  nativeEnum,\n  literal,\n} from 'valibot';\n\nexport enum PlayMode {\n  Bounce = 'bounce',\n  Normal = 'normal',\n}\n\nexport const PlayModeSchema = nativeEnum(PlayMode);\n\nexport const ManifestAnimationSchema = object({\n  autoplay: optional(boolean()),\n  defaultTheme: optional(string()),\n  direction: optional(union([literal(1), literal(-1)])),\n  hover: optional(boolean()),\n  id: string(),\n  intermission: optional(number()),\n  loop: optional(union([boolean(), number()])),\n  playMode: optional(PlayModeSchema),\n  speed: optional(number()),\n  themeColor: optional(string()),\n});\nexport type ManifestAnimation = Output<typeof ManifestAnimationSchema>;\n\nexport const ManifestThemeSchema = object({\n  animations: array(string()),\n  id: string(),\n});\nexport type ManifestTheme = Output<typeof ManifestThemeSchema>;\n\nexport const ManifestSchema = object({\n  activeAnimationId: optional(string()),\n  animations: array(ManifestAnimationSchema),\n  author: optional(string()),\n  custom: optional(record(string(), any())),\n  description: optional(string()),\n  generator: optional(string()),\n  keywords: optional(string()),\n  revision: optional(number()),\n  themes: optional(array(ManifestThemeSchema)),\n  states: optional(array(string())),\n  version: optional(string()),\n});\n\nexport type Manifest = Output<typeof ManifestSchema>;\n","/**\n * Copyright 2023 Design Barn Inc.\n */\n\n/* eslint-disable guard-for-in */\n\nimport type { Animation as AnimationData, Asset } from '@lottiefiles/lottie-types';\nimport type { UnzipFileFilter, Unzipped } from 'fflate';\nimport { unzip as fflateUnzip, strFromU8 } from 'fflate';\nimport { flatten, safeParse } from 'valibot';\n\nimport type { LottieStateMachine } from '../lottie-state-machine';\n\nimport type { Manifest } from './manifest';\nimport { ManifestSchema } from './manifest';\n\nexport interface MimeTypes {\n  [key: string]: string;\n}\n\nexport interface MimeCodes {\n  [key: string]: number[];\n}\n\nexport const MIME_TYPES: MimeTypes = {\n  jpeg: 'image/jpeg',\n  png: 'image/png',\n  gif: 'image/gif',\n  bmp: 'image/bmp',\n  svg: 'image/svg+xml',\n  webp: 'image/webp',\n  mpeg: 'audio/mpeg',\n  mp3: 'audio/mp3',\n};\n\nexport const MIME_CODES: MimeCodes = {\n  jpeg: [0xff, 0xd8, 0xff],\n  png: [0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a],\n  gif: [0x47, 0x49, 0x46],\n  bmp: [0x42, 0x4d],\n  webp: [0x52, 0x49, 0x46, 0x46, 0x57, 0x45, 0x42, 0x50],\n  svg: [0x3c, 0x3f, 0x78],\n  mp3: [0x49, 0x44, 0x33, 0x3, 0x00, 0x00, 0x00, 0x00],\n  mpeg: [0x49, 0x44, 0x33, 0x3, 0x00, 0x00, 0x00, 0x00],\n};\n\nexport interface MimeToExtension {\n  [key: string]: string;\n}\n\nexport const MIME_TO_EXTENSION: MimeToExtension = {\n  'image/jpeg': 'jpeg',\n  'image/png': 'png',\n  'image/gif': 'gif',\n  'image/bmp': 'bmp',\n  'image/svg+xml': 'svg',\n  'image/webp': 'webp',\n  'audio/mpeg': 'mpeg',\n  'audio/mp3': 'mp3',\n};\n\n/**\n * Converts a base64 string into a Uint8Array.\n *\n * @remarks\n * This function accepts a base64 string and returns a Uint8Array containing the decoded bytes.\n *\n * @param base64String - The base64-encoded string to decode.\n * @returns A Uint8Array containing the decoded bytes.\n *\n * @example\n * ```typescript\n * const base64 = 'SGVsbG8gd29ybGQ=';\n * const array = base64ToUint8Array(base64);\n * ```\n *\n * @public\n */\nexport const base64ToUint8Array = (base64String: string): Uint8Array => {\n  const withoutMeta = base64String.substring(base64String.indexOf(',') + 1);\n  const binaryString =\n    typeof window === 'undefined' ? Buffer.from(withoutMeta, 'base64').toString('binary') : atob(withoutMeta);\n\n  const uint8Array = new Uint8Array(binaryString.length);\n\n  for (let i = 0; i < binaryString.length; i += 1) {\n    uint8Array[i] = binaryString.charCodeAt(i);\n  }\n\n  return uint8Array;\n};\n\n/**\n * Determines the MIME type from a base64-encoded string.\n *\n * @remarks\n * This function accepts a base64-encoded string and determines its MIME type by looking at the first few bytes.\n *\n * @param base64 - The base64-encoded string to analyze.\n * @returns The MIME type as a string, or null if the type cannot be determined.\n *\n * @example\n * ```typescript\n * const base64 = 'data:image/jpeg;base64,...';\n * const mimeType = getMimeTypeFromBase64(base64);\n * ```\n *\n * @public\n */\nexport const getMimeTypeFromBase64 = (base64: string): string | null | undefined => {\n  let data: string | null = null;\n  let bytes: number[] = [];\n\n  if (!base64) return null;\n\n  const withoutMeta = base64.substring(base64.indexOf(',') + 1);\n\n  if (typeof window === 'undefined') {\n    data = Buffer.from(withoutMeta, 'base64').toString('binary');\n  } else {\n    data = atob(withoutMeta);\n  }\n\n  const bufData = new Uint8Array(data.length);\n\n  for (let i = 0; i < data.length; i += 1) {\n    bufData[i] = data.charCodeAt(i);\n  }\n\n  bytes = Array.from(bufData.subarray(0, 8));\n  for (const mimeType in MIME_CODES) {\n    const dataArr = MIME_CODES[mimeType];\n\n    if (dataArr && bytes.every((byte, index) => byte === dataArr[index])) {\n      return MIME_TYPES[mimeType];\n    }\n  }\n\n  return null;\n};\n\n/**\n * Determines the file extension from a base64-encoded string.\n *\n * @remarks\n * This function accepts a base64-encoded string and determines its file extension by examining the MIME type.\n *\n * @param base64 - The base64-encoded string to analyze.\n * @returns The file extension as a string, or 'png' if the extension cannot be determined.\n *\n * @example\n * ```typescript\n * const base64 = 'data:image/jpeg;base64,...';\n * const extension = getExtensionTypeFromBase64(base64);\n * ```\n *\n * @public\n */\nexport const getExtensionTypeFromBase64 = (base64: string): string | null => {\n  const mimeType = getMimeTypeFromBase64(base64);\n\n  if (!mimeType) {\n    const ext = base64.split(';')[0]?.split('/')[1];\n\n    if (ext) {\n      return MIME_TO_EXTENSION[ext] || 'png';\n    }\n\n    return 'png';\n  }\n\n  return MIME_TO_EXTENSION[mimeType] || 'png';\n};\n\nexport enum ErrorCodes {\n  ASSET_NOT_FOUND = 'ASSET_NOT_FOUND',\n  INVALID_DOTLOTTIE = 'INVALID_DOTLOTTIE',\n  INVALID_STATEMACHINE = 'INVALID_STATEMACHINE',\n  INVALID_URL = 'INVALID_URL',\n}\n\nexport class DotLottieError extends Error {\n  public code: ErrorCodes | undefined;\n\n  public constructor(message: string, code?: ErrorCodes) {\n    super(message);\n    this.name = '[dotlottie-js]';\n    this.code = code;\n  }\n}\n\n/**\n * Creates an Error object with the specified message.\n *\n * @remarks\n * This function accepts a message string and constructs a new Error object prefixed with \"[dotlottie-js]: \".\n *\n * @deprecated\n * This function has been deprecated in favor of using the {@link DotLottieError} class directly.\n *\n * @param message - The error message to include in the Error object.\n * @returns An Error object with the specified message, prefixed with \"[dotlottie-js]: \".\n *\n * @example\n * ```typescript\n * const message = 'DotLottie not found';\n * const error = createError(message);\n * ```\n *\n * @public\n */\nexport const createError = (message: string): Error => {\n  const error = new Error(`[dotlottie-js]: ${message}`);\n\n  return error;\n};\n\n/**\n * Validates a given URL string.\n *\n * @remarks\n * This function accepts a URL string and checks whether it's a valid URL according to the URL constructor.\n * It returns `true` if the URL is valid, `false` otherwise.\n *\n * @param url - The URL string to validate.\n * @returns `true` if the URL is valid, `false` otherwise.\n *\n * @example\n * ```typescript\n * const url = 'https://example.com';\n * const isValid = isValidURL(url); // true\n * ```\n *\n * @public\n */\nexport const isValidURL = (url: string): boolean => {\n  try {\n    // eslint-disable-next-line no-new\n    new URL(url);\n\n    return true;\n  } catch {\n    return false;\n  }\n};\n\n/**\n * Creates a data URL from a Uint8Array.\n *\n * @remarks\n * This function accepts a Uint8Array and a file extension, then converts the Uint8Array into a base64 data URL string.\n * The mimeType is determined based on the provided file extension, or defaults to 'image/png' if the extension is not recognized.\n *\n * @param uint8Data - The Uint8Array containing the binary data.\n * @param fileExtension - The file extension used to determine the mimeType (e.g., 'png', 'jpeg').\n * @returns The data URL string.\n *\n * @example\n * ```typescript\n * const uint8Data = new Uint8Array(...);\n * const fileExtension = 'png';\n * const dataUrl = dataUrlFromU8(uint8Data, fileExtension);\n * ```\n */\nexport function dataUrlFromU8(uint8Data: Uint8Array): string {\n  let base64: string;\n\n  if (typeof window === 'undefined') {\n    // Using Node.js Buffer for non-browser environments\n    base64 = Buffer.from(uint8Data).toString('base64');\n  } else {\n    // Using window.btoa for browser environments\n    const binaryString = Array.prototype.map.call(uint8Data, (byte: number) => String.fromCharCode(byte)).join('');\n\n    base64 = window.btoa(binaryString);\n  }\n\n  const mimeType = getMimeTypeFromBase64(base64);\n\n  return `data:${mimeType};base64,${base64}`;\n}\n\n/**\n * Checks if an asset is an image asset.\n *\n * @remarks\n * This function accepts an asset object and determines whether it represents an image asset.\n * It returns `true` if it's an image asset, `false` otherwise.\n *\n * @param asset - The asset object to check.\n * @returns `true` if it's an image asset, `false` otherwise.\n *\n * @example\n * ```typescript\n * const asset = { w: 100, h: 100, p: 'image.png' };\n * const isImage = isImageAsset(asset); // true\n * ```\n *\n * @public\n */\nexport function isImageAsset(asset: Asset.Value): asset is Asset.Image {\n  return 'w' in asset && 'h' in asset && !('xt' in asset) && 'p' in asset;\n}\n\n/**\n * Checks if an asset is an audio asset.\n *\n * @remarks\n * This function accepts an asset object and determines whether it represents an audio asset.\n * It returns `true` if it's an audio asset, `false` otherwise.\n *\n * @param asset - The asset object to check.\n * @returns `true` if it's an audio asset, `false` otherwise.\n *\n * @example\n * ```typescript\n * const asset = { e: 0, u: 'music/', p: 'audio.mp3' };\n * const isAudio = isAudioAsset(asset); // true\n * ```\n *\n * @public\n */\nexport function isAudioAsset(asset: Asset.Value): asset is Asset.Image {\n  return !('h' in asset) && !('w' in asset) && 'p' in asset && 'e' in asset && 'u' in asset && 'id' in asset;\n}\n\n/**\n * Unzips the .lottie file.\n *\n * @remarks\n * This function accepts a .lottie file as a Uint8Array and an optional filter function to refine the unzipping process.\n * It returns a Promise that resolves with the unzipped data.\n *\n * @param dotLottie - The .lottie data as a Uint8Array.\n * @param filter - The filter function to apply to the files. Defaults to a function that always returns true.\n * @returns A Promise that resolves with the unzipped data.\n * @throws {@link DotLottieError} if the .lottie data is not provided or is invalid.\n *\n * @example\n * ```typescript\n * const dotLottie = new Uint8Array(...);\n * const unzippedData = await unzipDotLottie(dotLottie);\n * ```\n *\n * @public\n */\nexport async function unzipDotLottie(\n  dotLottie: Uint8Array | undefined,\n  filter: UnzipFileFilter = (): boolean => true,\n): Promise<Unzipped> {\n  if (!(dotLottie instanceof Uint8Array)) {\n    throw new DotLottieError('DotLottie not found', ErrorCodes.INVALID_DOTLOTTIE);\n  }\n\n  const unzipped = await new Promise<Unzipped>((resolve, reject) => {\n    fflateUnzip(dotLottie, { filter }, (err, data) => {\n      if (err) {\n        reject(err);\n      }\n      resolve(data);\n    });\n  });\n\n  return unzipped;\n}\n\n/**\n * Unzips a specific file from a `.lottie` archive.\n *\n * @remarks\n * This function accepts a `.lottie` file as a `Uint8Array`, a path string representing the\n * target file to extract, and an optional filter function to further refine the extraction.\n * It returns a `Promise` that resolves to the unzipped `Uint8Array` of the target file.\n *\n * @param dotLottie - The `.lottie` file content as a `Uint8Array`.\n * @param path - The path of the target file within the `.lottie` archive to extract.\n * @param filter - An optional filter function to apply on the unzipping process.\n *                 Accepts a file object and returns a boolean indicating whether the file should be included.\n * @returns A `Promise` that resolves to the `Uint8Array` of the unzipped target file.\n *\n * @throws {@link DotLottieError} if the input is not a valid `.lottie` file or if the target file is not found.\n *\n * @example\n * ```typescript\n * const dotLottie = new Uint8Array(...);\n * const targetPath = 'images/image.png';\n * const unzippedFile = await unzipDotLottieFile(dotLottie, targetPath);\n * ```\n *\n * @public\n */\nexport async function unzipDotLottieFile(\n  dotLottie: Uint8Array,\n  path: string,\n  filter?: UnzipFileFilter,\n): Promise<Uint8Array | undefined> {\n  if (!(dotLottie instanceof Uint8Array)) {\n    throw new DotLottieError('DotLottie not found', ErrorCodes.INVALID_DOTLOTTIE);\n  }\n\n  const unzipped = await unzipDotLottie(dotLottie, (file) => file.name === path && (!filter || filter(file)));\n\n  return unzipped[path];\n}\n\n/**\n * Retrieves the manifest data from the given DotLottie object.\n *\n * @remarks\n * This function accepts a DotLottie object as a Uint8Array and extracts the manifest data from it.\n * The manifest contains metadata information about the .lottie file, such as the list of animations, themes, and image assets.\n * It returns a Promise that resolves to the manifest data or `undefined` if the manifest is not found.\n *\n * @param dotLottie - The Uint8Array of DotLottie data.\n * @returns A Promise that resolves with the manifest data or `undefined` if not found.\n *\n * @example\n * ```typescript\n * const dotLottie = new Uint8Array(...);\n * const manifestData = await getManifest(dotLottie);\n * ```\n *\n * @public\n */\nexport async function getManifest(dotLottie: Uint8Array): Promise<Manifest | undefined> {\n  const manifestFileName = 'manifest.json';\n\n  const unzipped = await unzipDotLottie(dotLottie, (file) => file.name === manifestFileName);\n\n  const unzippedManifest = unzipped[manifestFileName];\n\n  if (typeof unzippedManifest === 'undefined') {\n    return undefined;\n  }\n\n  return JSON.parse(strFromU8(unzippedManifest, false)) as Manifest;\n}\n\n/**\n * Validates the provided DotLottie data.\n *\n * @remarks\n * This function accepts a Uint8Array containing .lottie data and validates its structure and content.\n * It returns a Promise that resolves with an object containing a success boolean and an optional error string.\n *\n * @param dotLottie - The DotLottie data as a Uint8Array.\n * @returns A Promise that resolves with an object containing a success boolean and an optional error string.\n *\n * @example\n * ```typescript\n * const dotLottie = new Uint8Array(...);\n * const validationResult = await validateDotLottie(dotLottie);\n * ```\n *\n * @public\n */\nexport async function validateDotLottie(dotLottie: Uint8Array): Promise<{ error?: string; success: boolean }> {\n  if (!(dotLottie instanceof Uint8Array)) {\n    return { success: false, error: 'DotLottie not found' };\n  }\n\n  const manifest = await getManifest(dotLottie);\n\n  if (typeof manifest === 'undefined') {\n    return { success: false, error: 'Invalid .lottie file, manifest.json is missing' };\n  }\n\n  const manifestValidationResult = safeParse(ManifestSchema, manifest);\n\n  if (!manifestValidationResult.success) {\n    const error = `Invalid .lottie file, manifest.json structure is invalid, ${JSON.stringify(\n      flatten(manifestValidationResult.error).nested,\n      null,\n      2,\n    )}`;\n\n    return { success: false, error };\n  }\n\n  return { success: true };\n}\n\n/**\n * Loads a .lottie file from an ArrayBuffer.\n *\n * @remarks\n * This function takes an ArrayBuffer containing .lottie data and converts it into a Uint8Array.\n * It validates the data and returns a Promise that resolves with the DotLottie data as a Uint8Array.\n *\n * @param arrayBuffer - The ArrayBuffer containing .lottie data.\n * @returns A Promise that resolves with the DotLottie data as a Uint8Array.\n * @throws {@link DotLottieError} if the data is invalid.\n *\n * @example\n * ```typescript\n * const arrayBuffer = new ArrayBuffer(...);\n * const dotLottie = await loadFromArrayBuffer(arrayBuffer);\n * ```\n *\n * @public\n */\nexport async function loadFromArrayBuffer(arrayBuffer: ArrayBuffer): Promise<Uint8Array> {\n  const dotLottie = new Uint8Array(arrayBuffer);\n\n  const validationResult = await validateDotLottie(dotLottie);\n\n  if (validationResult.error) {\n    throw new DotLottieError(validationResult.error, ErrorCodes.INVALID_DOTLOTTIE);\n  }\n\n  return dotLottie;\n}\n\n/**\n * Loads a .lottie file from a given URL.\n *\n * @remarks\n * This function takes a URL string as input and fetches the .lottie file from the provided URL.\n * It returns a Promise that resolves with the DotLottie data as a Uint8Array.\n *\n * @param src - The URL source of the .lottie file.\n * @returns A Promise that resolves with the DotLottie data as a Uint8Array.\n * @throws {@link DotLottieError} if the URL is invalid or if the content type is incorrect.\n *\n * @example\n * ```typescript\n * const url = 'https://example.com/animation.lottie';\n * const dotLottie = await loadFromURL(url);\n * ```\n *\n * @public\n */\nexport async function loadFromURL(src: string): Promise<Uint8Array> {\n  if (!isValidURL(src)) {\n    throw new DotLottieError('Invalid url provided for .lottie file', ErrorCodes.INVALID_URL);\n  }\n\n  const response = await fetch(src);\n\n  const arrayBuffer = await response.arrayBuffer();\n\n  const contentType = response.headers.get('content-type');\n\n  if (!contentType?.includes('application/zip')) {\n    throw new DotLottieError(\n      'Invalid content type provided for .lottie file, expected application/zip',\n      ErrorCodes.INVALID_DOTLOTTIE,\n    );\n  }\n\n  const dotLottie = await loadFromArrayBuffer(arrayBuffer);\n\n  return dotLottie;\n}\n\n/**\n * Retrieves an audio from the given DotLottie object by its filename.\n *\n * @remarks\n * This function accepts a DotLottie object as a Uint8Array, the filename of the audio to retrieve, and an optional filter function.\n * It returns a Promise that resolves to the audio data URL or `undefined` if not found.\n *\n * @param dotLottie - The Uint8Array of DotLottie data.\n * @param filename - The filename of the image to get.\n * @param filter - An optional filter function to apply on the unzipping process.\n * @returns A Promise that resolves with the audio data URL or `undefined` if not found.\n *\n * @example\n * ```typescript\n * const dotLottie = new Uint8Array(...);\n * const filename = 'alarm.mp3';\n * const imageData = await getAudio(dotLottie, filename);\n * ```\n *\n * @public\n */\nexport async function getAudio(\n  dotLottie: Uint8Array,\n  filename: string,\n  filter?: UnzipFileFilter,\n): Promise<string | undefined> {\n  const audioFilename = `audio/${filename}`;\n\n  const unzipped = await unzipDotLottieFile(dotLottie, audioFilename, filter);\n\n  if (typeof unzipped === 'undefined') {\n    return undefined;\n  }\n\n  return dataUrlFromU8(unzipped);\n}\n\n/**\n * Retrieves all audio files from the given DotLottie object.\n *\n * @remarks\n * This function accepts a DotLottie object as a Uint8Array and an optional filter function to further refine the extraction.\n * It returns a Promise that resolves to a record containing the audio data URLs mapped by their ID.\n *\n * @param dotLottie - The Uint8Array of DotLottie data.\n * @param filter - An optional filter function to apply on the unzipping process.\n * @returns A Promise that resolves to a record containing the audio data URLs mapped by their ID.\n *\n * @example\n * ```typescript\n * const dotLottie = new Uint8Array(...);\n * const allAudio = await getAllAudio(dotLottie);\n * ```\n *\n * @public\n */\nexport async function getAllAudio(dotLottie: Uint8Array, filter?: UnzipFileFilter): Promise<Record<string, string>> {\n  const unzippedAudio = await unzipDotLottie(dotLottie, (file) => {\n    const name = file.name.replace('audio/', '');\n\n    return file.name.startsWith('audio/') && (!filter || filter({ ...file, name }));\n  });\n\n  const audio: Record<string, string> = {};\n\n  for (const audioPath in unzippedAudio) {\n    const unzippedSingleAudio = unzippedAudio[audioPath];\n\n    if (unzippedSingleAudio instanceof Uint8Array) {\n      const audioId = audioPath.replace('audio/', '');\n\n      audio[audioId] = dataUrlFromU8(unzippedSingleAudio);\n    }\n  }\n\n  return audio;\n}\n\n/**\n * Inlines audio assets for the given animations within a DotLottie object.\n *\n * @remarks\n * This function accepts a DotLottie object as a Uint8Array and a record containing the animations to process.\n * It identifies the audio used in the animations and replaces their references with the actual audio data.\n * This operation is performed asynchronously, and the function returns a Promise that resolves when the operation is complete.\n *\n * @param dotLottie - The DotLottie object containing the animations.\n * @param animations - A record containing the animations to process.\n * @returns A Promise that resolves when the operation is complete, returning nothing.\n *\n * @example\n * ```typescript\n * const dotLottie = new Uint8Array(...);\n * const animations = { animation1: {...}, animation2: {...} };\n * await inlineAudioAssets(dotLottie, animations);\n * ```\n *\n * @public\n */\nexport async function inlineAudioAssets(\n  dotLottie: Uint8Array,\n  animations: Record<string, AnimationData>,\n): Promise<void> {\n  const audioMap = new Map<string, Set<string>>();\n\n  for (const [animationId, animationData] of Object.entries(animations)) {\n    for (const asset of animationData.assets || []) {\n      if (isAudioAsset(asset)) {\n        const audioId = asset.p;\n\n        if (!audioMap.has(audioId)) {\n          audioMap.set(audioId, new Set());\n        }\n        audioMap.get(audioId)?.add(animationId);\n      }\n    }\n  }\n\n  const unzippedAudio = await getAllAudio(dotLottie, (file) => audioMap.has(file.name));\n\n  for (const [audioId, animationIdsSet] of audioMap) {\n    const audioDataURL = unzippedAudio[audioId];\n\n    if (audioDataURL) {\n      for (const animationId of animationIdsSet) {\n        const animationData = animations[animationId];\n\n        for (const asset of animationData?.assets || []) {\n          if (isAudioAsset(asset) && asset.p === audioId) {\n            asset.p = audioDataURL;\n            asset.u = '';\n            asset.e = 1;\n          }\n        }\n      }\n    }\n  }\n}\n\n/**\n * Retrieves an image from the given DotLottie object by its filename.\n *\n * @remarks\n * This function accepts a DotLottie object as a Uint8Array, the filename of the image to retrieve, and an optional filter function.\n * It returns a Promise that resolves to the image data URL or `undefined` if not found.\n *\n * @param dotLottie - The Uint8Array of DotLottie data.\n * @param filename - The filename of the image to get.\n * @param filter - An optional filter function to apply on the unzipping process.\n * @returns A Promise that resolves with the image data URL or `undefined` if not found.\n *\n * @example\n * ```typescript\n * const dotLottie = new Uint8Array(...);\n * const filename = 'image.png';\n * const imageData = await getImage(dotLottie, filename);\n * ```\n *\n * @public\n */\nexport async function getImage(\n  dotLottie: Uint8Array,\n  filename: string,\n  filter?: UnzipFileFilter,\n): Promise<string | undefined> {\n  const imageFilename = `images/${filename}`;\n\n  const unzipped = await unzipDotLottieFile(dotLottie, imageFilename, filter);\n\n  if (typeof unzipped === 'undefined') {\n    return undefined;\n  }\n\n  return dataUrlFromU8(unzipped);\n}\n\n/**\n * Retrieves all images from the given DotLottie object.\n *\n * @remarks\n * This function accepts a DotLottie object as a Uint8Array and an optional filter function to further refine the extraction.\n * It returns a Promise that resolves to a record containing the image data URLs mapped by their ID.\n *\n * @param dotLottie - The Uint8Array of DotLottie data.\n * @param filter - An optional filter function to apply on the unzipping process.\n * @returns A Promise that resolves to a record containing the image data URLs mapped by their ID.\n *\n * @example\n * ```typescript\n * const dotLottie = new Uint8Array(...);\n * const images = await getImages(dotLottie);\n * ```\n *\n * @public\n */\nexport async function getImages(dotLottie: Uint8Array, filter?: UnzipFileFilter): Promise<Record<string, string>> {\n  const unzippedImages = await unzipDotLottie(dotLottie, (file) => {\n    const name = file.name.replace('images/', '');\n\n    return file.name.startsWith('images/') && (!filter || filter({ ...file, name }));\n  });\n\n  const images: Record<string, string> = {};\n\n  for (const imagePath in unzippedImages) {\n    const unzippedImage = unzippedImages[imagePath];\n\n    if (unzippedImage instanceof Uint8Array) {\n      const imageId = imagePath.replace('images/', '');\n\n      images[imageId] = dataUrlFromU8(unzippedImage);\n    }\n  }\n\n  return images;\n}\n\n/**\n * Inlines image assets for the given animations within a DotLottie object.\n *\n * @remarks\n * This function accepts a DotLottie object as a Uint8Array and a record containing the animations to process.\n * It identifies the images used in the animations and replaces their references with the actual image data.\n * This operation is performed asynchronously, and the function returns a Promise that resolves when the operation is complete.\n *\n * @param dotLottie - The DotLottie object containing the animations.\n * @param animations - A record containing the animations to process.\n * @returns A Promise that resolves when the operation is complete, returning nothing.\n *\n * @example\n * ```typescript\n * const dotLottie = new Uint8Array(...);\n * const animations = { animation1: {...}, animation2: {...} };\n * await inlineImageAssets(dotLottie, animations);\n * ```\n *\n * @public\n */\nexport async function inlineImageAssets(\n  dotLottie: Uint8Array,\n  animations: Record<string, AnimationData>,\n): Promise<void> {\n  const imagesMap = new Map<string, Set<string>>();\n\n  for (const [animationId, animationData] of Object.entries(animations)) {\n    for (const asset of animationData.assets || []) {\n      if (isImageAsset(asset)) {\n        const imageId = asset.p;\n\n        if (!imagesMap.has(imageId)) {\n          imagesMap.set(imageId, new Set());\n        }\n        imagesMap.get(imageId)?.add(animationId);\n      }\n    }\n  }\n\n  const unzippedImages = await getImages(dotLottie, (file) => imagesMap.has(file.name));\n\n  for (const [imageId, animationIdsSet] of imagesMap) {\n    const imageDataURL = unzippedImages[imageId];\n\n    if (imageDataURL) {\n      for (const animationId of animationIdsSet) {\n        const animationData = animations[animationId];\n\n        for (const asset of animationData?.assets || []) {\n          if (isImageAsset(asset) && asset.p === imageId) {\n            asset.p = imageDataURL;\n            asset.u = '';\n            asset.e = 1;\n          }\n        }\n      }\n    }\n  }\n}\n\n/**\n * Retrieves an animation from the given DotLottie object by its ID.\n *\n * @remarks\n * This function accepts a DotLottie object as a Uint8Array, the animation ID to retrieve, and an optional inlineAssets option.\n * It returns a Promise that resolves to the animation data or `undefined` if not found.\n *\n * @param dotLottie - The Uint8Array of DotLottie data.\n * @param animationId - The animation ID to get.\n * @param options - An object containing an optional `inlineAssets` boolean to control whether image assets should be inlined.\n * @param filter - An optional function to filter the files to be unzipped.\n * @returns A Promise that resolves with the animation data or `undefined` if not found.\n *\n * @example\n * ```typescript\n * const dotLottie = new Uint8Array(...);\n * const animationId = 'example';\n * const animationData = await getAnimation(dotLottie, animationId, { inlineAssets: true });\n * ```\n *\n * @public\n */\nexport async function getAnimation(\n  dotLottie: Uint8Array,\n  animationId: string,\n  { inlineAssets }: { inlineAssets?: boolean } = {},\n  filter?: UnzipFileFilter,\n): Promise<AnimationData | undefined> {\n  const animationFilename = `animations/${animationId}.json`;\n\n  const unzippedAnimation = await unzipDotLottieFile(dotLottie, animationFilename, filter);\n\n  if (typeof unzippedAnimation === 'undefined') {\n    return undefined;\n  }\n\n  const animationData = JSON.parse(strFromU8(unzippedAnimation, false)) as AnimationData;\n\n  if (!inlineAssets) {\n    return animationData;\n  }\n\n  const animationsMap = {\n    [animationId]: animationData,\n  };\n\n  await inlineImageAssets(dotLottie, animationsMap);\n\n  await inlineAudioAssets(dotLottie, animationsMap);\n\n  return animationData;\n}\n\n/**\n * Retrieves the animations from the given DotLottie object, with optional filtering and asset inlining.\n *\n * @remarks\n * This function accepts a DotLottie object as a Uint8Array, an optional inlineAssets option, and an optional filter function.\n * It returns a Promise that resolves to a record containing the animation data mapped by their ID.\n *\n * @param dotLottie - The Uint8Array of DotLottie data.\n * @param options - An object containing an optional `inlineAssets` boolean to control whether assets should be inlined.\n * @param filter - An optional function to filter the files to be unzipped.\n * @returns A Promise that resolves to a record containing the animation data mapped by their ID.\n *\n * @example\n * ```typescript\n * const dotLottie = new Uint8Array(...);\n * const animations = await getAnimations(dotLottie, { inlineAssets: true });\n * ```\n *\n * @public\n */\nexport async function getAnimations(\n  dotLottie: Uint8Array,\n  { inlineAssets }: { inlineAssets?: boolean } = {},\n  filter?: UnzipFileFilter,\n): Promise<Record<string, AnimationData>> {\n  const animationsMap: Record<string, AnimationData> = {};\n  const unzippedAnimations = await unzipDotLottie(dotLottie, (file) => {\n    const filename = file.name.replace('animations/', '').replace('.json', '');\n\n    return file.name.startsWith('animations/') && (!filter || filter({ ...file, name: filename }));\n  });\n\n  for (const animationPath in unzippedAnimations) {\n    const data = unzippedAnimations[animationPath];\n\n    if (data instanceof Uint8Array) {\n      const animationId = animationPath.replace('animations/', '').replace('.json', '');\n      const animationData = JSON.parse(strFromU8(data, false)) as AnimationData;\n\n      animationsMap[animationId] = animationData;\n    }\n  }\n\n  if (!inlineAssets) {\n    return animationsMap;\n  }\n\n  await inlineImageAssets(dotLottie, animationsMap);\n\n  return animationsMap;\n}\n\n/**\n * Retrieves the themes from the given DotLottie object.\n *\n * @remarks\n * This function accepts a DotLottie object as a Uint8Array and an optional filter function to refine the extraction of themes.\n * It returns a Promise that resolves to a record containing the themes mapped by their ID.\n *\n * @param dotLottie - The DotLottie object containing the themes.\n * @param filter - An optional function to filter the files to be unzipped.\n * @returns A Promise that resolves to a record containing the themes mapped by their ID.\n *\n * @example\n * ```typescript\n * const dotLottie = new Uint8Array(...);\n * const themes = await getThemes(dotLottie);\n * ```\n */\nexport async function getThemes(dotLottie: Uint8Array, filter?: UnzipFileFilter): Promise<Record<string, string>> {\n  const themesMap: Record<string, string> = {};\n\n  const unzippedThemes = await unzipDotLottie(dotLottie, (file) => {\n    const name = file.name.replace('themes/', '').replace('.lss', '');\n\n    return file.name.startsWith('themes/') && (!filter || filter({ ...file, name }));\n  });\n\n  for (const themePath in unzippedThemes) {\n    const data = unzippedThemes[themePath];\n\n    if (data instanceof Uint8Array) {\n      const themeId = themePath.replace('themes/', '').replace('.lss', '');\n\n      themesMap[themeId] = strFromU8(data, false);\n    }\n  }\n\n  return themesMap;\n}\n\n/**\n * Retrieves a specific theme by ID from the given DotLottie object.\n *\n * @remarks\n * This function accepts a DotLottie object as a Uint8Array, the theme ID to retrieve, and an optional filter function.\n * It returns a Promise that resolves to the theme as a string or `undefined` if not found.\n *\n * @param dotLottie - The DotLottie object containing the theme.\n * @param themeId - The ID of the theme to retrieve.\n * @param filter - An optional function to filter the files to be unzipped.\n * @returns A Promise that resolves to the theme as a string or `undefined` if not found.\n *\n * @example\n * ```typescript\n * const dotLottie = new Uint8Array(...);\n * const themeId = 'dark';\n * const theme = await getTheme(dotLottie, themeId);\n * ```\n */\nexport async function getTheme(\n  dotLottie: Uint8Array,\n  themeId: string,\n  filter?: UnzipFileFilter,\n): Promise<string | undefined> {\n  const themeFilename = `themes/${themeId}.lss`;\n\n  const unzippedTheme = await unzipDotLottieFile(dotLottie, themeFilename, filter);\n\n  if (typeof unzippedTheme === 'undefined') {\n    return undefined;\n  }\n\n  return strFromU8(unzippedTheme, false);\n}\n\n/**\n * Retrieves the state machines from the given DotLottie object.\n *\n * @remarks\n * This function accepts a DotLottie object as a Uint8Array and an optional filter function to refine the extraction of state machines.\n * It returns a Promise that resolves to a record containing the state machines mapped by their ID.\n *\n * @param dotLottie - The DotLottie object containing the state machines.\n * @param filter - An optional function to filter the files to be unzipped.\n * @returns A Promise that resolves to a record containing the state machines mapped by their ID.\n *\n * @example\n * ```typescript\n * const dotLottie = new Uint8Array(...);\n * const machines = await getStateMachines(dotLottie);\n * ```\n */\nexport async function getStateMachines(\n  dotLottie: Uint8Array,\n  filter?: UnzipFileFilter,\n): Promise<Record<string, string>> {\n  const statesMap: Record<string, string> = {};\n\n  const unzippedStates = await unzipDotLottie(dotLottie, (file) => {\n    const name = file.name.replace('states/', '').replace('.json', '');\n\n    return file.name.startsWith('states/') && (!filter || filter({ ...file, name }));\n  });\n\n  for (const statePath in unzippedStates) {\n    const data = unzippedStates[statePath];\n\n    if (data instanceof Uint8Array) {\n      const themeId = statePath.replace('states/', '').replace('.json', '');\n\n      statesMap[themeId] = strFromU8(data, false);\n    }\n  }\n\n  return statesMap;\n}\n\n/**\n * Retrieves a specific state machine by ID from the given DotLottie object.\n *\n * @remarks\n * This function accepts a DotLottie object as a Uint8Array, the state ID to retrieve, and an optional filter function.\n * It returns a Promise that resolves to the state machine as a string or `undefined` if not found.\n *\n * @param dotLottie - The DotLottie object containing the theme.\n * @param stateMachineId - The ID of the state machine to retrieve.\n * @param filter - An optional function to filter the files to be unzipped.\n * @returns A Promise that resolves to the state machine as a string or `undefined` if not found.\n *\n * @example\n * ```typescript\n * const dotLottie = new Uint8Array(...);\n * const stateMachineId = 'walk';\n * const stateMachine = await getState(dotLottie, stateMachineId);\n * ```\n */\nexport async function getStateMachine(\n  dotLottie: Uint8Array,\n  stateMachineId: string,\n  filter?: UnzipFileFilter,\n): Promise<LottieStateMachine | undefined> {\n  const stateMachineFilename = `states/${stateMachineId}.json`;\n\n  const unzippedStateMachine = await unzipDotLottieFile(dotLottie, stateMachineFilename, filter);\n\n  if (typeof unzippedStateMachine === 'undefined') {\n    return undefined;\n  }\n\n  const stateMachine = JSON.parse(strFromU8(unzippedStateMachine, false)) as LottieStateMachine;\n\n  return stateMachine;\n}\n","/**\n * Copyright 2023 Design Barn Inc.\n */\n\nimport type { Animation as AnimationType } from '@lottiefiles/lottie-types';\nimport type { ZipOptions } from 'fflate';\n\nimport type { LottieThemeCommon } from './dotlottie-theme-common';\nimport type { LottieAudioCommon } from './lottie-audio-common';\nimport type { LottieImageCommon } from './lottie-image-common';\nimport type { ManifestAnimation } from './manifest';\nimport { PlayMode } from './manifest';\nimport { DotLottieError, createError, isAudioAsset } from './utils';\n\nexport type AnimationData = AnimationType;\n\nexport interface ExportOptions {\n  inlineAssets?: boolean;\n}\n\nexport interface AnimationOptions extends ManifestAnimation {\n  data?: AnimationData;\n  defaultActiveAnimation?: boolean;\n  url?: string;\n  zipOptions?: ZipOptions;\n}\n\nexport class LottieAnimationCommon {\n  protected _data?: AnimationData;\n\n  protected _id: string = '';\n\n  protected _url?: string;\n\n  private _direction: ManifestAnimation['direction'];\n\n  private _speed: number;\n\n  private _playMode: PlayMode;\n\n  private _loop: boolean | number;\n\n  private _autoplay: boolean;\n\n  private _hover: boolean;\n\n  private _intermission: number;\n\n  private _zipOptions: ZipOptions;\n\n  // Will be translated to 'activeAnimationId' inside of the manifest file\n  // This indicates if the player should play this animation by default rather than the first in the list.\n  protected _defaultActiveAnimation: boolean;\n\n  protected _imageAssets: LottieImageCommon[] = [];\n\n  protected _audioAssets: LottieAudioCommon[] = [];\n\n  protected _themesMap: Map<string, LottieThemeCommon> = new Map();\n\n  protected _defaultTheme?: string;\n\n  public constructor(options: AnimationOptions) {\n    this._requireValidOptions(options);\n\n    this._id = options.id;\n\n    this._zipOptions = options.zipOptions ?? {};\n\n    if (options.data) this._data = options.data;\n    if (options.url) this._url = options.url;\n\n    this._direction = options.direction ?? 1;\n    this._speed = options.speed ?? 1.0;\n    this._playMode = options.playMode ?? PlayMode.Normal;\n    this._loop = options.loop ?? false;\n    this._autoplay = options.autoplay ?? false;\n    this._defaultActiveAnimation = options.defaultActiveAnimation ?? false;\n    this._hover = options.hover ?? false;\n    this._intermission = options.intermission ?? 0;\n  }\n\n  public async toBase64(): Promise<string> {\n    throw createError('lottie animation controls tobase64 not implemented!');\n  }\n\n  public get zipOptions(): ZipOptions {\n    return this._zipOptions;\n  }\n\n  public set zipOptions(zipOptions: ZipOptions) {\n    this._zipOptions = zipOptions;\n  }\n\n  public get id(): string {\n    return this._id;\n  }\n\n  public set id(id: string) {\n    this._requireValidId(id);\n\n    this._id = id;\n  }\n\n  public get defaultTheme(): string | undefined {\n    return this._defaultTheme;\n  }\n\n  public set defaultTheme(defaultTheme: string | undefined) {\n    if (defaultTheme) {\n      this._defaultTheme = defaultTheme;\n    }\n  }\n\n  public get themes(): LottieThemeCommon[] {\n    return Array.from(this._themesMap.values());\n  }\n\n  public set themes(themes: LottieThemeCommon[]) {\n    this._themesMap = new Map();\n    themes.forEach((theme) => {\n      this._themesMap.set(theme.id, theme);\n    });\n  }\n\n  public get imageAssets(): LottieImageCommon[] {\n    return this._imageAssets;\n  }\n\n  public set imageAssets(imageAssets: LottieImageCommon[]) {\n    this._imageAssets = imageAssets;\n  }\n\n  public get audioAssets(): LottieAudioCommon[] {\n    return this._audioAssets;\n  }\n\n  public set audioAssets(audioAssets: LottieAudioCommon[]) {\n    this._audioAssets = audioAssets;\n  }\n\n  public get data(): AnimationData | undefined {\n    return this._data;\n  }\n\n  public set data(data: AnimationData | undefined) {\n    this._requireValidLottieData(data);\n\n    this._data = data;\n  }\n\n  public get url(): string | undefined {\n    return this._url;\n  }\n\n  public set url(url: string | undefined) {\n    this._requireValidUrl(url);\n\n    this._url = url;\n  }\n\n  public get direction(): ManifestAnimation['direction'] {\n    return this._direction;\n  }\n\n  public set direction(direction: ManifestAnimation['direction']) {\n    this._direction = direction;\n  }\n\n  public get speed(): number {\n    return this._speed;\n  }\n\n  public set speed(speed: number) {\n    this._speed = speed;\n  }\n\n  public get playMode(): PlayMode {\n    return this._playMode;\n  }\n\n  public set playMode(playMode: PlayMode) {\n    this._playMode = playMode;\n  }\n\n  public get loop(): boolean | number {\n    return this._loop;\n  }\n\n  public set loop(loop: boolean | number) {\n    this._requireValidLoop(loop);\n    this._loop = loop;\n  }\n\n  public get autoplay(): boolean {\n    return this._autoplay;\n  }\n\n  public set autoplay(autoplay: boolean) {\n    this._autoplay = autoplay;\n  }\n\n  public get defaultActiveAnimation(): boolean {\n    return this._defaultActiveAnimation;\n  }\n\n  public set defaultActiveAnimation(defaultActiveAnimation: boolean) {\n    this._defaultActiveAnimation = defaultActiveAnimation;\n  }\n\n  public get hover(): boolean {\n    return this._hover;\n  }\n\n  public set hover(hover: boolean) {\n    this._hover = hover;\n  }\n\n  public get intermission(): number {\n    return this._intermission;\n  }\n\n  public set intermission(intermission: number) {\n    this._requireValidIntermission(intermission);\n    this._intermission = intermission;\n  }\n\n  public addTheme(theme: LottieThemeCommon): void {\n    this._themesMap.set(theme.id, theme);\n  }\n\n  public removeTheme(themeId: string): void {\n    this._themesMap.delete(themeId);\n  }\n\n  /**\n   * Return the animation data as an array buffer.\n   * @returns data - The animation data as an ArrayBuffer.\n   * @throws Error - if the animation data is not set and the url is not provided.\n   * @throws Error - if the animation data is not a valid Lottie animation data object.\n   * @throws Error - if the fetch request fails.\n   */\n  public async toArrayBuffer(options: ExportOptions = {}): Promise<ArrayBuffer> {\n    const dataJson = await this.toJSON(options);\n\n    return new TextEncoder().encode(JSON.stringify(dataJson)).buffer;\n  }\n\n  protected async _extractImageAssets(): Promise<boolean> {\n    throw new DotLottieError('_extractImageAssets(): Promise<boolean> method not implemented in concrete class');\n  }\n\n  protected async _extractAudioAssets(): Promise<boolean> {\n    throw new DotLottieError('_extractAudioAssets(): Promise<boolean> method not implemented in concrete class');\n  }\n\n  /**\n   * Return the animation data as a blob.\n   * @returns blob - The animation data as a Blob.\n   * @throws Error - if the animation data is not set and the url is not provided.\n   * @throws Error - if the animation data is not a valid Lottie animation data object.\n   * @throws Error - if the fetch request fails.\n   */\n  public async toBlob(options: ExportOptions = {}): Promise<Blob> {\n    const dataJson = await this.toJSON(options);\n\n    return new Blob([JSON.stringify(dataJson)], { type: 'application/json' });\n  }\n\n  /**\n   * Return the animation data as a JSON object.\n   * If the animation data is not already set, it will be fetched from the provided url.\n   * @returns data - The animation data.\n   * @throws Error - if the animation data is not a valid Lottie animation data object.\n   * @throws Error - if the fetch request fails.\n   */\n  public async toJSON(options: ExportOptions = {}): Promise<AnimationType> {\n    if (this._url && !this._data) {\n      this._data = await this._fromUrl(this._url);\n    }\n\n    this._requireValidLottieData(this._data);\n\n    if (this._data.assets?.length) {\n      // Even if the user wants to inline the assets, we still need to extract them\n      await this._extractImageAssets();\n      await this._extractAudioAssets();\n\n      if (options.inlineAssets) {\n        const animationAssets = this.data?.assets as AnimationType['assets'];\n\n        if (!animationAssets)\n          throw new DotLottieError(\"Failed to inline assets, the animation's assets are undefined.\");\n\n        const images = this.imageAssets;\n        const audios = this.audioAssets;\n\n        for (const asset of animationAssets) {\n          if ('w' in asset && 'h' in asset && !('xt' in asset) && 'p' in asset) {\n            for (const image of images) {\n              if (image.fileName === asset.p) {\n                // encoded is true\n                asset.e = 1;\n                asset.u = '';\n                asset.p = await image.toDataURL();\n              }\n            }\n          } else if (isAudioAsset(asset)) {\n            // Audio asset\n            for (const audio of audios) {\n              if (audio.fileName === asset.p) {\n                // encoded is true\n                asset.e = 1;\n                asset.u = '';\n                asset.p = await audio.toDataURL();\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return this._data;\n  }\n\n  /**\n   * Fetch the animation data from the provided url.\n   * @param url - The url to fetch the animation data from.\n   * @returns animationData - The animation data.\n   * @throws Error - if the fetch request fails.\n   * @throws Error - if the data object is not a valid Lottie animation data object.\n   */\n  private async _fromUrl(url: string): Promise<AnimationType> {\n    const response = await fetch(url);\n\n    const text = await response.text();\n\n    let json;\n\n    try {\n      json = JSON.parse(text);\n    } catch (error) {\n      if (error instanceof Error) {\n        throw createError(`${error.message}: Invalid json returned from url`);\n      }\n    }\n\n    this._requireValidLottieData(json as AnimationData);\n\n    return json;\n  }\n\n  /**\n   * Ensure that the provided url is a valid string.\n   * The url must be a non-empty string, otherwise an error will be thrown.\n   * @param url - The url to validate.\n   * @throws Error - if the url is not a valid string.\n   *\n   */\n  private _requireValidUrl(url: string | undefined): asserts url is string {\n    try {\n      // eslint-disable-next-line no-new\n      new URL(url || '');\n    } catch (_err) {\n      throw createError('Invalid animation url');\n    }\n  }\n\n  /**\n   * Ensure that the provided data object is a valid Lottie animation data object.\n   * The data object must contain the following mandatory properties: v, ip, op, layers, fr, w, h.\n   * If the data object does not contain all mandatory properties, an error will be thrown.\n   * @param data - The data object to validate.\n   * @throws Error - if the data object is not a valid Lottie animation data object.\n   */\n  private _requireValidLottieData(data: AnimationData | undefined): asserts data is AnimationData {\n    const mandatoryLottieProperties = ['v', 'ip', 'op', 'layers', 'fr', 'w', 'h'];\n\n    const hasAllMandatoryProperties = mandatoryLottieProperties.every((field) =>\n      Object.prototype.hasOwnProperty.call(data, field),\n    );\n\n    if (!hasAllMandatoryProperties) {\n      throw createError('Received invalid Lottie data.');\n    }\n  }\n\n  /**\n   * Ensure that the provided id is a valid string.\n   * The id must be a non-empty string, otherwise an error will be thrown.\n   * @param id - The id to validate.\n   * @throws Error - if the id is not a valid string.\n   */\n  private _requireValidId(id: string | undefined): asserts id is string {\n    if (!id) throw createError('Invalid animation id');\n  }\n\n  /**\n   * Ensure that the provided url is a valid string.\n   * The url must be a non-empty string, otherwise an error will be thrown.\n   * @param url - The url to validate.\n   * @throws Error - if the url is not a valid string.\n   *\n   */\n  private _requireValidDirection(direction: number): asserts direction is number {\n    if (direction !== -1 && direction !== 1) {\n      throw createError('Direction can only be -1 (backwards) or 1 (forwards)');\n    }\n  }\n\n  /**\n   * Ensure that the provided intermission is a valid, positive number.\n   * @param intermission - The intermission to validate.\n   * @throws Error - if the intermission is not a valid number.\n   */\n  private _requireValidIntermission(intermission: number): asserts intermission is number {\n    if (intermission < 0 || !Number.isInteger(intermission)) {\n      throw createError('intermission must be a positive number');\n    }\n  }\n\n  /**\n   * Ensure that the provided loop is a valid, positive number or boolean.\n   * @param loop - The loop to validate.\n   * @throws Error - if the loop is not a valid number or boolean.\n   */\n  private _requireValidLoop(loop: number | boolean): asserts loop is number | boolean {\n    if (typeof loop === 'number' && (!Number.isInteger(loop) || loop < 0)) {\n      throw createError('loop must be a positive number or boolean');\n    }\n  }\n\n  /**\n   * Ensure that the provided options object is a valid AnimationOptions object.\n   * The options object must contain the following mandatory properties: id, data or url.\n   * If the options object does not contain all mandatory properties, an error will be thrown.\n   * @param options - The options object to validate.\n   * @throws Error - if the options object is not a valid AnimationOptions object.\n   * @throws Error - if the id is not a valid string.\n   * @throws Error - if the data object is not a valid Lottie animation data object.\n   * @throws Error - if the url is not a valid url string.\n   * @throws Error - if the data object is not set and the url is not provided.\n   */\n  private _requireValidOptions(options: AnimationOptions): asserts options is AnimationOptions {\n    this._requireValidId(options.id);\n\n    if (!options.data && !options.url) {\n      throw createError('No data or url provided.');\n    }\n\n    if (options.data) {\n      this._requireValidLottieData(options.data);\n    }\n\n    if (options.url) {\n      this._requireValidUrl(options.url);\n    }\n\n    if (options.direction) {\n      this._requireValidDirection(options.direction);\n    }\n\n    if (options.intermission) {\n      this._requireValidIntermission(options.intermission);\n    }\n\n    if (options.loop) {\n      this._requireValidLoop(options.loop);\n    }\n  }\n}\n","/**\n * Copyright 2023 Design Barn Inc.\n */\n\nimport type { ZipOptions } from 'fflate';\n\nimport type { LottieAnimationCommon } from './lottie-animation-common';\nimport { dataUrlFromU8, createError } from './utils';\n\nexport type ImageData = string | ArrayBuffer | Blob;\n\nexport interface ImageOptions {\n  data?: ImageData;\n  fileName: string;\n  id: string;\n  parentAnimations?: LottieAnimationCommon[];\n  url?: string;\n  zipOptions?: ZipOptions;\n}\n\nexport class LottieImageCommon {\n  protected _data?: ImageData;\n\n  protected _id: string = '';\n\n  protected _url?: string;\n\n  protected _fileName: string = '';\n\n  protected _parentAnimations: LottieAnimationCommon[];\n\n  protected _zipOptions: ZipOptions;\n\n  public constructor(options: ImageOptions) {\n    this._requireValidId(options.id);\n    this._requireValidFileName(options.fileName);\n\n    this._zipOptions = options.zipOptions ?? {};\n\n    if (options.data) {\n      this._data = options.data;\n    }\n\n    if (options.id) {\n      this._id = options.id;\n    }\n\n    if (options.url) {\n      this._url = options.url;\n    }\n\n    if (options.fileName) {\n      this._fileName = options.fileName;\n    }\n\n    this._parentAnimations = options.parentAnimations || [];\n  }\n\n  public get zipOptions(): ZipOptions {\n    return this._zipOptions;\n  }\n\n  public set zipOptions(zipOptions: ZipOptions) {\n    this._zipOptions = zipOptions;\n  }\n\n  /**\n   * Ensure that the provided id is a valid string.\n   * The id must be a non-empty string, otherwise an error will be thrown.\n   * @param id - The id to validate.\n   * @throws Error - if the id is not a valid string.\n   */\n  private _requireValidId(id: string | undefined): asserts id is string {\n    if (!id) throw createError('Invalid image id');\n  }\n\n  /**\n   * Ensure that the provided fileName is a valid string.\n   * The fileName must be a non-empty string, otherwise an error will be thrown.\n   * @param fileName - The fileName to validate.\n   * @throws Error - if the fileName is not a valid string.\n   */\n  private _requireValidFileName(fileName: string | undefined): asserts fileName is string {\n    if (!fileName) throw createError('Invalid image fileName');\n  }\n\n  public get fileName(): string {\n    return this._fileName;\n  }\n\n  public set fileName(fileName: string) {\n    if (!fileName) throw createError('Invalid image file name');\n    this._fileName = fileName;\n  }\n\n  public get id(): string {\n    return this._id;\n  }\n\n  public set id(id: string) {\n    if (!id) throw createError('Invalid image id');\n    this._id = id;\n  }\n\n  public get data(): ImageData | undefined {\n    return this._data;\n  }\n\n  public set data(data: ImageData | undefined) {\n    if (!data) {\n      throw createError('Invalid data');\n    }\n\n    this._data = data;\n  }\n\n  public get url(): string | undefined {\n    return this._url;\n  }\n\n  public set url(url: string | undefined) {\n    if (!url) {\n      throw new Error('Invalid url');\n    }\n\n    this._url = url;\n  }\n\n  public get parentAnimations(): LottieAnimationCommon[] {\n    return this._parentAnimations;\n  }\n\n  public set parentAnimations(parentAnimations: LottieAnimationCommon[]) {\n    this._parentAnimations = parentAnimations;\n  }\n\n  public async toDataURL(): Promise<string> {\n    if (this._data && this._isDataURL(this._data)) return this.data as string;\n\n    const arrayBuffer = await this.toArrayBuffer();\n\n    return dataUrlFromU8(new Uint8Array(arrayBuffer));\n  }\n\n  /**\n   * Renames the id and fileName to newName.\n   * @param newName - A new id and filename for the image.\n   */\n  public renameImage(newName: string): void {\n    this.id = newName;\n\n    if (this.fileName) {\n      let fileExt = this.fileName.split('.').pop();\n\n      if (!fileExt) {\n        fileExt = '.png';\n      }\n      // Default to png if the file extension isn't available\n      this.fileName = `${newName}.${fileExt}`;\n    }\n  }\n\n  public async toArrayBuffer(): Promise<ArrayBuffer> {\n    const blob = await (await this.toBlob()).arrayBuffer();\n\n    return blob;\n  }\n\n  public async toBlob(): Promise<Blob> {\n    if (!this._data && this._url) {\n      this._data = await this._fromUrlToBlob(this._url);\n    }\n\n    if (!this._data) {\n      throw new Error('Invalid data');\n    }\n\n    if (this._isDataURL(this._data)) {\n      const data = this._data as string;\n\n      const [header, base64] = data.split(',');\n\n      // If the data doesnt contain the encoding URL, return it\n      if ((!header || !base64) && data.length) {\n        return new Blob([data]);\n      }\n\n      if (!header || !base64) {\n        throw new Error('Invalid data');\n      }\n\n      // eslint-disable-next-line require-unicode-regexp\n      const type = header.replace('data:', '').replace(/;base64$/, '');\n\n      return new Blob([base64], { type });\n    }\n\n    if (this._isArrayBuffer(this._data)) {\n      return new Blob([this._data]);\n    }\n\n    if (this._isBlob(this._data)) {\n      return this._data as Blob;\n    }\n\n    throw new Error('Invalid data');\n  }\n\n  protected async _fromUrlToBlob(url: string): Promise<Blob> {\n    const response = await fetch(url);\n\n    return response.blob();\n  }\n\n  protected _isArrayBuffer(data: ImageData): boolean {\n    return data instanceof ArrayBuffer;\n  }\n\n  protected _isDataURL(data: ImageData): boolean {\n    return typeof data === 'string' && data.startsWith('data:');\n  }\n\n  protected _isBlob(data: ImageData): boolean {\n    return data instanceof Blob;\n  }\n}\n","/**\n * Copyright 2023 Design Barn Inc.\n */\n\nimport type { ImageOptions } from './common';\nimport { LottieImageCommon } from './common';\n\nexport class LottieImage extends LottieImageCommon {\n  public constructor(options: ImageOptions) {\n    super(options);\n  }\n}\n","/**\n * Copyright 2023 Design Barn Inc.\n */\n\nimport type { ZipOptions } from 'fflate';\n\nimport type { LottieAnimationCommon } from './lottie-animation-common';\nimport { dataUrlFromU8, DotLottieError, ErrorCodes } from './utils';\n\nexport type AudioData = string | ArrayBuffer | Blob;\n\nexport interface AudioOptions {\n  data?: AudioData;\n  fileName: string;\n  id: string;\n  parentAnimations?: LottieAnimationCommon[];\n  url?: string;\n  zipOptions?: ZipOptions;\n}\n\nexport class LottieAudioCommon {\n  protected _data?: AudioData;\n\n  protected _id: string = '';\n\n  protected _url?: string;\n\n  protected _fileName: string = '';\n\n  protected _parentAnimations: LottieAnimationCommon[];\n\n  protected _zipOptions: ZipOptions;\n\n  public constructor(options: AudioOptions) {\n    this._requireValidId(options.id);\n    this._requireValidFileName(options.fileName);\n\n    this._zipOptions = options.zipOptions ?? {};\n\n    if (options.data) {\n      this._data = options.data;\n    }\n\n    if (options.id) {\n      this._id = options.id;\n    }\n\n    if (options.url) {\n      this._url = options.url;\n    }\n\n    if (options.fileName) {\n      this._fileName = options.fileName;\n    }\n\n    this._parentAnimations = options.parentAnimations || [];\n  }\n\n  public get zipOptions(): ZipOptions {\n    return this._zipOptions;\n  }\n\n  public set zipOptions(zipOptions: ZipOptions) {\n    this._zipOptions = zipOptions;\n  }\n\n  public get fileName(): string {\n    return this._fileName;\n  }\n\n  public set fileName(fileName: string) {\n    if (!fileName) throw new DotLottieError('Invalid audio file name', ErrorCodes.ASSET_NOT_FOUND);\n    this._fileName = fileName;\n  }\n\n  public get id(): string {\n    return this._id;\n  }\n\n  public set id(id: string) {\n    if (!id) throw new DotLottieError('Invalid audio id', ErrorCodes.ASSET_NOT_FOUND);\n    this._id = id;\n  }\n\n  public get data(): AudioData | undefined {\n    return this._data;\n  }\n\n  public set data(data: AudioData | undefined) {\n    if (!data) {\n      throw new DotLottieError('Invalid data');\n    }\n\n    this._data = data;\n  }\n\n  public get parentAnimations(): LottieAnimationCommon[] {\n    return this._parentAnimations;\n  }\n\n  public set parentAnimations(parentAnimations: LottieAnimationCommon[]) {\n    this._parentAnimations = parentAnimations;\n  }\n\n  public async toDataURL(): Promise<string> {\n    if (this._data && this._isDataURL(this._data)) return this.data as string;\n\n    const arrayBuffer = await this.toArrayBuffer();\n\n    return dataUrlFromU8(new Uint8Array(arrayBuffer));\n  }\n\n  /**\n   * Renames the id and fileName to newName.\n   * @param newName - A new id and filename for the audio.\n   */\n  public renameAudio(newName: string): void {\n    this.id = newName;\n\n    if (this.fileName) {\n      let fileExt = this.fileName.split('.').pop();\n\n      if (!fileExt) {\n        fileExt = '.png';\n      }\n      // Default to png if the file extension isn't available\n      this.fileName = `${newName}.${fileExt}`;\n    }\n  }\n\n  public async toArrayBuffer(): Promise<ArrayBuffer> {\n    const blob = await (await this.toBlob()).arrayBuffer();\n\n    return blob;\n  }\n\n  public async toBlob(): Promise<Blob> {\n    if (!this._data && this._url) {\n      this._data = await this._fromUrlToBlob(this._url);\n    }\n\n    if (!this._data) {\n      throw new Error('Invalid data');\n    }\n\n    if (this._isDataURL(this._data)) {\n      const data = this._data as string;\n\n      const [header, base64] = data.split(',');\n\n      // If the data doesnt contain the encoding URL, return it\n      if ((!header || !base64) && data.length) {\n        return new Blob([data]);\n      }\n\n      if (!header || !base64) {\n        throw new Error('Invalid data');\n      }\n\n      // eslint-disable-next-line require-unicode-regexp\n      const type = header.replace('data:', '').replace(/;base64$/, '');\n\n      return new Blob([base64], { type });\n    }\n\n    if (this._isArrayBuffer(this._data)) {\n      return new Blob([this._data]);\n    }\n\n    if (this._isBlob(this._data)) {\n      return this._data as Blob;\n    }\n\n    throw new Error('Invalid data');\n  }\n\n  protected async _fromUrlToBlob(url: string): Promise<Blob> {\n    const response = await fetch(url);\n\n    return response.blob();\n  }\n\n  protected _isArrayBuffer(data: AudioData): boolean {\n    return data instanceof ArrayBuffer;\n  }\n\n  protected _isDataURL(data: AudioData): boolean {\n    return typeof data === 'string' && data.startsWith('data:');\n  }\n\n  protected _isBlob(data: AudioData): boolean {\n    return data instanceof Blob;\n  }\n\n  /**\n   * Ensure that the provided id is a valid string.\n   * The id must be a non-empty string, otherwise an error will be thrown.\n   * @param id - The id to validate.\n   * @throws Error - if the id is not a valid string.\n   */\n  private _requireValidId(id: string | undefined): asserts id is string {\n    if (!id) throw new DotLottieError('Invalid audio id');\n  }\n\n  /**\n   * Ensure that the provided fileName is a valid string.\n   * The fileName must be a non-empty string, otherwise an error will be thrown.\n   * @param fileName - The fileName to validate.\n   * @throws Error - if the fileName is not a valid string.\n   */\n  private _requireValidFileName(fileName: string | undefined): asserts fileName is string {\n    if (!fileName) throw new DotLottieError('Invalid audio fileName');\n  }\n}\n","/**\n * Copyright 2023 Design Barn Inc.\n */\n\nimport type { AudioOptions } from '../common';\nimport { LottieAudioCommon } from '../common';\n\nexport class LottieAudio extends LottieAudioCommon {\n  public constructor(options: AudioOptions) {\n    super(options);\n  }\n}\n","/**\n * Copyright 2023 Design Barn Inc.\n */\n\nimport type { Animation as AnimationType } from '@lottiefiles/lottie-types';\n\nimport type { AnimationOptions } from './common';\nimport { DotLottieError, LottieAnimationCommon, createError, getExtensionTypeFromBase64, isAudioAsset } from './common';\nimport { LottieImage } from './lottie-image';\nimport { LottieAudio } from './node/lottie-audio';\n\nexport class LottieAnimation extends LottieAnimationCommon {\n  public constructor(options: AnimationOptions) {\n    super(options);\n  }\n\n  /**\n   * Return the animation data as a base 64 encoded string.\n   *\n   * @returns data - The animation data as a base64 encoded string.\n   * @throws Error - if the animation data is not set and the url is not provided.\n   * @throws Error - if the animation data is not a valid Lottie animation data object.\n   * @throws Error - if the fetch request fails.\n   */\n  public override async toBase64(): Promise<string> {\n    const data = await this.toArrayBuffer();\n\n    if (typeof window === 'undefined') return Buffer.from(data).toString('base64');\n\n    const uint8Array = new Uint8Array(data);\n    const binaryString = uint8Array.reduce((acc, val) => acc + String.fromCharCode(val), '');\n\n    return window.btoa(binaryString);\n  }\n\n  /**\n   * Extract image assets from the anima tion.\n   *\n   * @returns boolean - true on error otherwise false on success\n   */\n  protected override async _extractImageAssets(): Promise<boolean> {\n    if (!this._data) throw createError('Asset extraction failed.');\n\n    const animationAssets = this._data.assets as AnimationType['assets'];\n\n    if (!animationAssets) throw createError('Asset extraction failed.');\n\n    for (const asset of animationAssets) {\n      if ('w' in asset && 'h' in asset && !('xt' in asset) && 'p' in asset) {\n        const imageData = asset.p.split(',');\n\n        // Image data is invalid\n        if (!imageData.length || !imageData[0] || !imageData[1]) {\n          break;\n        }\n\n        let extType = null;\n        const fileType = getExtensionTypeFromBase64(asset.p);\n\n        extType = fileType;\n\n        const fileName = `${asset.id}.${extType}`;\n\n        this._imageAssets.push(\n          new LottieImage({\n            data: asset.p,\n            id: asset.id,\n            fileName,\n            parentAnimations: [this],\n          }),\n        );\n\n        asset.p = fileName;\n        asset.u = '/images/';\n        asset.e = 0;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   *\n   * Extract audio assets from the animation.\n   *\n   * @returns boolean - true on error otherwise false on success\n   */\n  protected override async _extractAudioAssets(): Promise<boolean> {\n    if (!this._data) throw new DotLottieError('Asset extraction failed.');\n\n    const animationAssets = this._data.assets as AnimationType['assets'];\n\n    if (!animationAssets) throw new DotLottieError('Asset extraction failed.');\n\n    for (const asset of animationAssets) {\n      if (isAudioAsset(asset)) {\n        const audioData = asset.p.split(',');\n\n        // Image data is invalid\n        if (!audioData.length || !audioData[0] || !audioData[1]) {\n          break;\n        }\n\n        let extType = null;\n        const fileType = getExtensionTypeFromBase64(asset.p);\n\n        extType = fileType;\n\n        const fileName = `${asset.id}.${extType}`;\n\n        this._audioAssets.push(\n          new LottieAudio({\n            data: asset.p,\n            id: asset.id,\n            fileName,\n            parentAnimations: [this],\n          }),\n        );\n\n        asset.p = fileName;\n        asset.u = '/audio/';\n        asset.e = 0;\n      }\n    }\n\n    return false;\n  }\n}\n"]}