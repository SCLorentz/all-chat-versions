// src/error/flatten/flatten.ts
function flatten(arg1) {
  return (Array.isArray(arg1) ? arg1 : arg1.issues).reduce(
    (flatErrors, issue) => {
      if (issue.path) {
        const path = issue.path.map(({ key }) => key).join(".");
        flatErrors.nested[path] = [
          ...flatErrors.nested[path] || [],
          issue.message
        ];
      } else {
        flatErrors.root = [...flatErrors.root || [], issue.message];
      }
      return flatErrors;
    },
    { nested: {} }
  );
}

// src/error/ValiError/ValiError.ts
var ValiError = class extends Error {
  issues;
  /**
   * Creates a Valibot error with useful information.
   *
   * @param issues The error issues.
   */
  constructor(issues) {
    super(issues[0].message);
    this.name = "ValiError";
    this.issues = issues;
  }
};

// src/methods/brand/brand.ts
var symbol = Symbol("brand");
function brand(schema, name) {
  return schema;
}

// src/methods/coerce/coerce.ts
function coerce(schema, action) {
  return {
    ...schema,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      return schema._parse(action(input), info);
    }
  };
}

// src/methods/coerce/coerceAsync.ts
function coerceAsync(schema, action) {
  return {
    ...schema,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async _parse(input, info) {
      return schema._parse(await action(input), info);
    }
  };
}

// src/methods/fallback/fallback.ts
function fallback(schema, value2) {
  return {
    ...schema,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      const result = schema._parse(input, info);
      return {
        output: result.issues ? typeof value2 === "function" ? value2({
          input,
          issues: result.issues
        }) : value2 : result.output
      };
    }
  };
}

// src/methods/fallback/fallbackAsync.ts
function fallbackAsync(schema, value2) {
  return {
    ...schema,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async _parse(input, info) {
      const result = await schema._parse(input, info);
      return {
        output: result.issues ? typeof value2 === "function" ? value2({
          input,
          issues: result.issues
        }) : value2 : result.output
      };
    }
  };
}

// src/methods/is/is.ts
function is(schema, input) {
  return !schema._parse(input, { abortEarly: true }).issues;
}

// src/utils/executePipe/utils/getIssue/getIssue.ts
function getIssue(info, issue) {
  return {
    reason: info?.reason,
    validation: issue.validation,
    origin: info?.origin || "value",
    message: issue.message,
    input: issue.input,
    abortEarly: info?.abortEarly,
    abortPipeEarly: info?.abortPipeEarly
  };
}

// src/utils/executePipe/utils/getPipeInfo/getPipeInfo.ts
function getPipeInfo(info, reason) {
  return {
    reason,
    origin: info?.origin,
    abortEarly: info?.abortEarly,
    abortPipeEarly: info?.abortPipeEarly
  };
}

// src/utils/executePipe/executePipe.ts
function executePipe(input, pipe, parseInfo, reason) {
  if (!pipe || !pipe.length) {
    return { output: input };
  }
  let pipeInfo;
  let issues;
  let output = input;
  for (const action of pipe) {
    const result = action(output);
    if (result.issue) {
      pipeInfo = pipeInfo || getPipeInfo(parseInfo, reason);
      const issue = getIssue(pipeInfo, result.issue);
      issues ? issues.push(issue) : issues = [issue];
      if (pipeInfo.abortEarly || pipeInfo.abortPipeEarly) {
        break;
      }
    } else {
      output = result.output;
    }
  }
  return issues ? { issues } : { output };
}

// src/utils/executePipe/executePipeAsync.ts
async function executePipeAsync(input, pipe, parseInfo, reason) {
  if (!pipe || !pipe.length) {
    return { output: input };
  }
  let pipeInfo;
  let issues;
  let output = input;
  for (const action of pipe) {
    const result = await action(output);
    if (result.issue) {
      pipeInfo = pipeInfo || getPipeInfo(parseInfo, reason);
      const issue = getIssue(pipeInfo, result.issue);
      issues ? issues.push(issue) : issues = [issue];
      if (pipeInfo.abortEarly || pipeInfo.abortPipeEarly) {
        break;
      }
    } else {
      output = result.output;
    }
  }
  return issues ? { issues } : { output };
}

// src/utils/getDefaultArgs/getDefaultArgs.ts
function getDefaultArgs(arg1, arg2) {
  return !arg1 || typeof arg1 === "string" ? [arg1, arg2] : [void 0, arg1];
}

// src/utils/getIssues/getIssues.ts
function getIssues(info, reason, validation, message, input, issues) {
  return {
    issues: [
      {
        reason,
        validation,
        origin: info?.origin || "value",
        message,
        input,
        issues,
        abortEarly: info?.abortEarly,
        abortPipeEarly: info?.abortPipeEarly
      }
    ]
  };
}

// src/utils/isLuhnAlgo/isLuhnAlgo.ts
function isLuhnAlgo(input) {
  const number2 = input.replace(/\D/g, "");
  let length2 = number2.length;
  let bit = 1;
  let sum = 0;
  while (length2) {
    const value2 = +number2[--length2];
    bit ^= 1;
    sum += bit ? [0, 2, 4, 6, 8, 1, 3, 5, 7, 9][value2] : value2;
  }
  return sum % 10 === 0;
}

// src/schemas/any/any.ts
function any(pipe = []) {
  return {
    /**
     * The schema type.
     */
    schema: "any",
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      return executePipe(input, pipe, info, "any");
    }
  };
}

// src/schemas/any/anyAsync.ts
function anyAsync(pipe = []) {
  return {
    /**
     * The schema type.
     */
    schema: "any",
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async _parse(input, info) {
      return executePipeAsync(input, pipe, info, "any");
    }
  };
}

// src/schemas/array/array.ts
function array(item, arg2, arg3) {
  const [error, pipe] = getDefaultArgs(arg2, arg3);
  return {
    /**
     * The schema type.
     */
    schema: "array",
    /**
     * The array item schema.
     */
    array: { item },
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (!Array.isArray(input)) {
        return getIssues(info, "type", "array", error || "Invalid type", input);
      }
      let issues;
      const output = [];
      for (let key = 0; key < input.length; key++) {
        const value2 = input[key];
        const result = item._parse(value2, info);
        if (result.issues) {
          const pathItem = {
            schema: "array",
            input,
            key,
            value: value2
          };
          for (const issue of result.issues) {
            if (issue.path) {
              issue.path.unshift(pathItem);
            } else {
              issue.path = [pathItem];
            }
            issues?.push(issue);
          }
          if (!issues) {
            issues = result.issues;
          }
          if (info?.abortEarly) {
            break;
          }
        } else {
          output.push(result.output);
        }
      }
      return issues ? { issues } : executePipe(output, pipe, info, "array");
    }
  };
}

// src/schemas/array/arrayAsync.ts
function arrayAsync(item, arg2, arg3) {
  const [error, pipe] = getDefaultArgs(arg2, arg3);
  return {
    /**
     * The schema type.
     */
    schema: "array",
    /**
     * The array item schema.
     */
    array: { item },
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async _parse(input, info) {
      if (!Array.isArray(input)) {
        return getIssues(info, "type", "array", error || "Invalid type", input);
      }
      let issues;
      const output = [];
      await Promise.all(
        input.map(async (value2, key) => {
          if (!(info?.abortEarly && issues)) {
            const result = await item._parse(value2, info);
            if (!(info?.abortEarly && issues)) {
              if (result.issues) {
                const pathItem = {
                  schema: "array",
                  input,
                  key,
                  value: value2
                };
                for (const issue of result.issues) {
                  if (issue.path) {
                    issue.path.unshift(pathItem);
                  } else {
                    issue.path = [pathItem];
                  }
                  issues?.push(issue);
                }
                if (!issues) {
                  issues = result.issues;
                }
                if (info?.abortEarly) {
                  throw null;
                }
              } else {
                output[key] = result.output;
              }
            }
          }
        })
      ).catch(() => null);
      return issues ? { issues } : executePipeAsync(output, pipe, info, "array");
    }
  };
}

// src/schemas/bigint/bigint.ts
function bigint(arg1, arg2) {
  const [error, pipe] = getDefaultArgs(arg1, arg2);
  return {
    /**
     * The schema type.
     */
    schema: "bigint",
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (typeof input !== "bigint") {
        return getIssues(
          info,
          "type",
          "bigint",
          error || "Invalid type",
          input
        );
      }
      return executePipe(input, pipe, info, "bigint");
    }
  };
}

// src/schemas/bigint/bigintAsync.ts
function bigintAsync(arg1, arg2) {
  const [error, pipe] = getDefaultArgs(arg1, arg2);
  return {
    /**
     * The schema type.
     */
    schema: "bigint",
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async _parse(input, info) {
      if (typeof input !== "bigint") {
        return getIssues(
          info,
          "type",
          "bigint",
          error || "Invalid type",
          input
        );
      }
      return executePipeAsync(input, pipe, info, "bigint");
    }
  };
}

// src/schemas/blob/blob.ts
function blob(arg1, arg2) {
  const [error, pipe] = getDefaultArgs(arg1, arg2);
  return {
    /**
     * The schema type.
     */
    schema: "blob",
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (!(input instanceof Blob)) {
        return getIssues(info, "type", "blob", error || "Invalid type", input);
      }
      return executePipe(input, pipe, info, "blob");
    }
  };
}

// src/schemas/blob/blobAsync.ts
function blobAsync(arg1, arg2) {
  const [error, pipe] = getDefaultArgs(arg1, arg2);
  return {
    /**
     * The schema type.
     */
    schema: "blob",
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async _parse(input, info) {
      if (!(input instanceof Blob)) {
        return getIssues(info, "type", "blob", error || "Invalid type", input);
      }
      return executePipeAsync(input, pipe, info, "blob");
    }
  };
}

// src/schemas/boolean/boolean.ts
function boolean(arg1, arg2) {
  const [error, pipe] = getDefaultArgs(arg1, arg2);
  return {
    /**
     * The schema type.
     */
    schema: "boolean",
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (typeof input !== "boolean") {
        return getIssues(
          info,
          "type",
          "boolean",
          error || "Invalid type",
          input
        );
      }
      return executePipe(input, pipe, info, "boolean");
    }
  };
}

// src/schemas/boolean/booleanAsync.ts
function booleanAsync(arg1, arg2) {
  const [error, pipe] = getDefaultArgs(arg1, arg2);
  return {
    /**
     * The schema type.
     */
    schema: "boolean",
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async _parse(input, info) {
      if (typeof input !== "boolean") {
        return getIssues(
          info,
          "type",
          "boolean",
          error || "Invalid type",
          input
        );
      }
      return executePipeAsync(input, pipe, info, "boolean");
    }
  };
}

// src/schemas/date/date.ts
function date(arg1, arg2) {
  const [error, pipe] = getDefaultArgs(arg1, arg2);
  return {
    /**
     * The schema type.
     */
    schema: "date",
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (!(input instanceof Date)) {
        return getIssues(info, "type", "date", error || "Invalid type", input);
      }
      return executePipe(input, pipe, info, "date");
    }
  };
}

// src/schemas/date/dateAsync.ts
function dateAsync(arg1, arg2) {
  const [error, pipe] = getDefaultArgs(arg1, arg2);
  return {
    /**
     * The schema type.
     */
    schema: "date",
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async _parse(input, info) {
      if (!(input instanceof Date)) {
        return getIssues(info, "type", "date", error || "Invalid type", input);
      }
      return executePipeAsync(input, pipe, info, "date");
    }
  };
}

// src/schemas/enumType/enumType.ts
function enumType(enumValue, error) {
  return {
    /**
     * The schema type.
     */
    schema: "enum",
    /**
     * The enum value.
     */
    enum: enumValue,
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (!enumValue.includes(input)) {
        return getIssues(info, "type", "enum", error || "Invalid type", input);
      }
      return { output: input };
    }
  };
}

// src/schemas/enumType/enumTypeAsync.ts
function enumTypeAsync(enumValue, error) {
  return {
    /**
     * The schema type.
     */
    schema: "enum",
    /**
     * The enum value.
     */
    enum: enumValue,
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async _parse(input, info) {
      if (!enumValue.includes(input)) {
        return getIssues(info, "type", "enum", error || "Invalid type", input);
      }
      return { output: input };
    }
  };
}

// src/schemas/instance/instance.ts
function instance(of, arg2, arg3) {
  const [error, pipe] = getDefaultArgs(arg2, arg3);
  return {
    /**
     * The schema type.
     */
    schema: "instance",
    /**
     * The class of the instance.
     */
    class: of,
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (!(input instanceof of)) {
        return getIssues(
          info,
          "type",
          "instance",
          error || "Invalid type",
          input
        );
      }
      return executePipe(input, pipe, info, "instance");
    }
  };
}

// src/schemas/instance/instanceAsync.ts
function instanceAsync(of, arg2, arg3) {
  const [error, pipe] = getDefaultArgs(arg2, arg3);
  return {
    /**
     * The schema type.
     */
    schema: "instance",
    /**
     * The class of the instance.
     */
    class: of,
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async _parse(input, info) {
      if (!(input instanceof of)) {
        return getIssues(
          info,
          "type",
          "instance",
          error || "Invalid type",
          input
        );
      }
      return executePipeAsync(input, pipe, info, "instance");
    }
  };
}

// src/schemas/literal/literal.ts
function literal(literal2, error) {
  return {
    /**
     * The schema type.
     */
    schema: "literal",
    /**
     * The literal value.
     */
    literal: literal2,
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (input !== literal2) {
        return getIssues(
          info,
          "type",
          "literal",
          error || "Invalid type",
          input
        );
      }
      return { output: input };
    }
  };
}

// src/schemas/literal/literalAsync.ts
function literalAsync(literal2, error) {
  return {
    /**
     * The schema type.
     */
    schema: "literal",
    /**
     * The literal value.
     */
    literal: literal2,
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async _parse(input, info) {
      if (input !== literal2) {
        return getIssues(
          info,
          "type",
          "literal",
          error || "Invalid type",
          input
        );
      }
      return { output: input };
    }
  };
}

// src/schemas/map/map.ts
function map(key, value2, arg3, arg4) {
  const [error, pipe] = getDefaultArgs(arg3, arg4);
  return {
    /**
     * The schema type.
     */
    schema: "map",
    /**
     * The map key and value schema.
     */
    map: { key, value: value2 },
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (!(input instanceof Map)) {
        return getIssues(info, "type", "map", error || "Invalid type", input);
      }
      let issues;
      const output = /* @__PURE__ */ new Map();
      for (const [inputKey, inputValue] of input.entries()) {
        let pathItem;
        const keyResult = key._parse(inputKey, {
          origin: "key",
          abortEarly: info?.abortEarly,
          abortPipeEarly: info?.abortPipeEarly
        });
        if (keyResult.issues) {
          pathItem = {
            schema: "map",
            input,
            key: inputKey,
            value: inputValue
          };
          for (const issue of keyResult.issues) {
            if (issue.path) {
              issue.path.unshift(pathItem);
            } else {
              issue.path = [pathItem];
            }
            issues?.push(issue);
          }
          if (!issues) {
            issues = keyResult.issues;
          }
          if (info?.abortEarly) {
            break;
          }
        }
        const valueResult = value2._parse(inputValue, info);
        if (valueResult.issues) {
          pathItem = pathItem || {
            schema: "map",
            input,
            key: inputKey,
            value: inputValue
          };
          for (const issue of valueResult.issues) {
            if (issue.path) {
              issue.path.unshift(pathItem);
            } else {
              issue.path = [pathItem];
            }
            issues?.push(issue);
          }
          if (!issues) {
            issues = valueResult.issues;
          }
          if (info?.abortEarly) {
            break;
          }
        }
        if (!keyResult.issues && !valueResult.issues) {
          output.set(keyResult.output, valueResult.output);
        }
      }
      return issues ? { issues } : executePipe(output, pipe, info, "map");
    }
  };
}

// src/schemas/map/mapAsync.ts
function mapAsync(key, value2, arg3, arg4) {
  const [error, pipe] = getDefaultArgs(arg3, arg4);
  return {
    /**
     * The schema type.
     */
    schema: "map",
    /**
     * The map key and value schema.
     */
    map: { key, value: value2 },
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async _parse(input, info) {
      if (!(input instanceof Map)) {
        return getIssues(info, "type", "map", error || "Invalid type", input);
      }
      const output = /* @__PURE__ */ new Map();
      let issues;
      await Promise.all(
        Array.from(input.entries()).map(async ([inputKey, inputValue]) => {
          let pathItem;
          const [keyResult, valueResult] = await Promise.all(
            [
              { schema: key, value: inputKey, origin: "key" },
              { schema: value2, value: inputValue, origin: "value" }
            ].map(async ({ schema, value: value3, origin }) => {
              if (!(info?.abortEarly && issues)) {
                const result = await schema._parse(value3, {
                  origin,
                  abortEarly: info?.abortEarly,
                  abortPipeEarly: info?.abortPipeEarly
                });
                if (!(info?.abortEarly && issues)) {
                  if (result.issues) {
                    pathItem = pathItem || {
                      schema: "map",
                      input,
                      key: inputKey,
                      value: inputValue
                    };
                    for (const issue of result.issues) {
                      if (issue.path) {
                        issue.path.unshift(pathItem);
                      } else {
                        issue.path = [pathItem];
                      }
                      issues?.push(issue);
                    }
                    if (!issues) {
                      issues = result.issues;
                    }
                    if (info?.abortEarly) {
                      throw null;
                    }
                  } else {
                    return result;
                  }
                }
              }
            })
          ).catch(() => []);
          if (keyResult && valueResult) {
            output.set(keyResult.output, valueResult.output);
          }
        })
      );
      return issues ? { issues } : executePipeAsync(input, pipe, info, "map");
    }
  };
}

// src/schemas/nan/nan.ts
function nan(error) {
  return {
    /**
     * The schema type.
     */
    schema: "nan",
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (!Number.isNaN(input)) {
        return getIssues(info, "type", "nan", error || "Invalid type", input);
      }
      return { output: input };
    }
  };
}

// src/schemas/nan/nanAsync.ts
function nanAsync(error) {
  return {
    /**
     * The schema type.
     */
    schema: "nan",
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async _parse(input, info) {
      if (!Number.isNaN(input)) {
        return getIssues(info, "type", "nan", error || "Invalid type", input);
      }
      return { output: input };
    }
  };
}

// src/schemas/nativeEnum/nativeEnum.ts
function nativeEnum(nativeEnum2, error) {
  return {
    /**
     * The schema type.
     */
    schema: "native_enum",
    /**
     * The native enum value.
     */
    nativeEnum: nativeEnum2,
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (!Object.values(nativeEnum2).includes(input)) {
        return getIssues(
          info,
          "type",
          "native_enum",
          error || "Invalid type",
          input
        );
      }
      return { output: input };
    }
  };
}

// src/schemas/nativeEnum/nativeEnumAsync.ts
function nativeEnumAsync(nativeEnum2, error) {
  return {
    /**
     * The schema type.
     */
    schema: "native_enum",
    /**
     * The native enum value.
     */
    nativeEnum: nativeEnum2,
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async _parse(input, info) {
      if (!Object.values(nativeEnum2).includes(input)) {
        return getIssues(
          info,
          "type",
          "native_enum",
          error || "Invalid type",
          input
        );
      }
      return { output: input };
    }
  };
}

// src/schemas/never/never.ts
function never(error) {
  return {
    /**
     * The schema type.
     */
    schema: "never",
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      return getIssues(info, "type", "never", error || "Invalid type", input);
    }
  };
}

// src/schemas/never/neverAsync.ts
function neverAsync(error) {
  return {
    /**
     * The schema type.
     */
    schema: "never",
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async _parse(input, info) {
      return getIssues(info, "type", "never", error || "Invalid type", input);
    }
  };
}

// src/schemas/nonNullable/nonNullable.ts
function nonNullable(wrapped, error) {
  return {
    /**
     * The schema type.
     */
    schema: "non_nullable",
    /**
     * The wrapped schema.
     */
    wrapped,
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (input === null) {
        return getIssues(
          info,
          "type",
          "non_nullable",
          error || "Invalid type",
          input
        );
      }
      return wrapped._parse(input, info);
    }
  };
}

// src/schemas/nonNullable/nonNullableAsync.ts
function nonNullableAsync(wrapped, error) {
  return {
    /**
     * The schema type.
     */
    schema: "non_nullable",
    /**
     * The wrapped schema.
     */
    wrapped,
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async _parse(input, info) {
      if (input === null) {
        return getIssues(
          info,
          "type",
          "non_nullable",
          error || "Invalid type",
          input
        );
      }
      return wrapped._parse(input, info);
    }
  };
}

// src/schemas/nonNullish/nonNullish.ts
function nonNullish(wrapped, error) {
  return {
    /**
     * The schema type.
     */
    schema: "non_nullish",
    /**
     * The wrapped schema.
     */
    wrapped,
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (input === null || input === void 0) {
        return getIssues(
          info,
          "type",
          "non_nullish",
          error || "Invalid type",
          input
        );
      }
      return wrapped._parse(input, info);
    }
  };
}

// src/schemas/nonNullish/nonNullishAsync.ts
function nonNullishAsync(wrapped, error) {
  return {
    /**
     * The schema type.
     */
    schema: "non_nullish",
    /**
     * The wrapped schema.
     */
    wrapped,
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async _parse(input, info) {
      if (input === null || input === void 0) {
        return getIssues(
          info,
          "type",
          "non_nullish",
          error || "Invalid type",
          input
        );
      }
      return wrapped._parse(input, info);
    }
  };
}

// src/schemas/nonOptional/nonOptional.ts
function nonOptional(wrapped, error) {
  return {
    /**
     * The schema type.
     */
    schema: "non_optional",
    /**
     * The wrapped schema.
     */
    wrapped,
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (input === void 0) {
        return getIssues(
          info,
          "type",
          "non_optional",
          error || "Invalid type",
          input
        );
      }
      return wrapped._parse(input, info);
    }
  };
}

// src/schemas/nonOptional/nonOptionalAsync.ts
function nonOptionalAsync(wrapped, error) {
  return {
    /**
     * The schema type.
     */
    schema: "non_optional",
    /**
     * The wrapped schema.
     */
    wrapped,
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async _parse(input, info) {
      if (input === void 0) {
        return getIssues(
          info,
          "type",
          "non_optional",
          error || "Invalid type",
          input
        );
      }
      return wrapped._parse(input, info);
    }
  };
}

// src/schemas/nullable/nullable.ts
function nullable(wrapped) {
  return {
    /**
     * The schema type.
     */
    schema: "nullable",
    /**
     * The wrapped schema.
     */
    wrapped,
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (input === null) {
        return { output: input };
      }
      return wrapped._parse(input, info);
    }
  };
}

// src/schemas/nullable/nullableAsync.ts
function nullableAsync(wrapped) {
  return {
    /**
     * The schema type.
     */
    schema: "nullable",
    /**
     * The wrapped schema.
     */
    wrapped,
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async _parse(input, info) {
      if (input === null) {
        return { output: input };
      }
      return wrapped._parse(input, info);
    }
  };
}

// src/schemas/nullish/nullish.ts
function nullish(wrapped) {
  return {
    /**
     * The schema type.
     */
    schema: "nullish",
    /**
     * The wrapped schema.
     */
    wrapped,
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (input === null || input === void 0) {
        return { output: input };
      }
      return wrapped._parse(input, info);
    }
  };
}

// src/schemas/nullish/nullishAsync.ts
function nullishAsync(wrapped) {
  return {
    /**
     * The schema type.
     */
    schema: "nullish",
    /**
     * The wrapped schema.
     */
    wrapped,
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async _parse(input, info) {
      if (input === null || input === void 0) {
        return { output: input };
      }
      return wrapped._parse(input, info);
    }
  };
}

// src/schemas/nullType/nullType.ts
function nullType(error) {
  return {
    /**
     * The schema type.
     */
    schema: "null",
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (input !== null) {
        return getIssues(info, "type", "null", error || "Invalid type", input);
      }
      return { output: input };
    }
  };
}

// src/schemas/nullType/nullTypeAsync.ts
function nullTypeAsync(error) {
  return {
    /**
     * The schema type.
     */
    schema: "null",
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async _parse(input, info) {
      if (input !== null) {
        return getIssues(info, "type", "null", error || "Invalid type", input);
      }
      return { output: input };
    }
  };
}

// src/schemas/number/number.ts
function number(arg1, arg2) {
  const [error, pipe] = getDefaultArgs(arg1, arg2);
  return {
    /**
     * The schema type.
     */
    schema: "number",
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (typeof input !== "number") {
        return getIssues(
          info,
          "type",
          "number",
          error || "Invalid type",
          input
        );
      }
      return executePipe(input, pipe, info, "number");
    }
  };
}

// src/schemas/number/numberAsync.ts
function numberAsync(arg1, arg2) {
  const [error, pipe] = getDefaultArgs(arg1, arg2);
  return {
    /**
     * The schema type.
     */
    schema: "number",
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async _parse(input, info) {
      if (typeof input !== "number") {
        return getIssues(
          info,
          "type",
          "number",
          error || "Invalid type",
          input
        );
      }
      return executePipeAsync(input, pipe, info, "number");
    }
  };
}

// src/schemas/object/object.ts
function object(object2, arg2, arg3) {
  const [error, pipe] = getDefaultArgs(arg2, arg3);
  let cachedEntries;
  return {
    /**
     * The schema type.
     */
    schema: "object",
    /**
     * The object schema.
     */
    object: object2,
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (!input || typeof input !== "object") {
        return getIssues(
          info,
          "type",
          "object",
          error || "Invalid type",
          input
        );
      }
      cachedEntries = cachedEntries || Object.entries(object2);
      let issues;
      const output = {};
      for (const [key, schema] of cachedEntries) {
        const value2 = input[key];
        const result = schema._parse(value2, info);
        if (result.issues) {
          const pathItem = {
            schema: "object",
            input,
            key,
            value: value2
          };
          for (const issue of result.issues) {
            if (issue.path) {
              issue.path.unshift(pathItem);
            } else {
              issue.path = [pathItem];
            }
            issues?.push(issue);
          }
          if (!issues) {
            issues = result.issues;
          }
          if (info?.abortEarly) {
            break;
          }
        } else {
          output[key] = result.output;
        }
      }
      return issues ? { issues } : executePipe(
        output,
        pipe,
        info,
        "object"
      );
    }
  };
}

// src/schemas/object/objectAsync.ts
function objectAsync(object2, arg2, arg3) {
  const [error, pipe] = getDefaultArgs(arg2, arg3);
  let cachedEntries;
  return {
    /**
     * The schema type.
     */
    schema: "object",
    /**
     * The object schema.
     */
    object: object2,
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async _parse(input, info) {
      if (!input || typeof input !== "object") {
        return getIssues(
          info,
          "type",
          "object",
          error || "Invalid type",
          input
        );
      }
      cachedEntries = cachedEntries || Object.entries(object2);
      let issues;
      const output = {};
      await Promise.all(
        cachedEntries.map(async ([key, schema]) => {
          if (!(info?.abortEarly && issues)) {
            const value2 = input[key];
            const result = await schema._parse(value2, info);
            if (!(info?.abortEarly && issues)) {
              if (result.issues) {
                const pathItem = {
                  schema: "object",
                  input,
                  key,
                  value: value2
                };
                for (const issue of result.issues) {
                  if (issue.path) {
                    issue.path.unshift(pathItem);
                  } else {
                    issue.path = [pathItem];
                  }
                  issues?.push(issue);
                }
                if (!issues) {
                  issues = result.issues;
                }
                if (info?.abortEarly) {
                  throw null;
                }
              } else {
                output[key] = result.output;
              }
            }
          }
        })
      ).catch(() => null);
      return issues ? { issues } : executePipeAsync(
        output,
        pipe,
        info,
        "object"
      );
    }
  };
}

// src/schemas/optional/optional.ts
function optional(wrapped) {
  return {
    /**
     * The schema type.
     */
    schema: "optional",
    /**
     * The wrapped schema.
     */
    wrapped,
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (input === void 0) {
        return { output: input };
      }
      return wrapped._parse(input, info);
    }
  };
}

// src/schemas/optional/optionalAsync.ts
function optionalAsync(wrapped) {
  return {
    /**
     * The schema type.
     */
    schema: "optional",
    /**
     * The wrapped schema.
     */
    wrapped,
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async _parse(input, info) {
      if (input === void 0) {
        return { output: input };
      }
      return wrapped._parse(input, info);
    }
  };
}

// src/schemas/string/string.ts
function string(arg1, arg2) {
  const [error, pipe] = getDefaultArgs(arg1, arg2);
  return {
    /**
     * The schema type.
     */
    schema: "string",
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (typeof input !== "string") {
        return getIssues(
          info,
          "type",
          "string",
          error || "Invalid type",
          input
        );
      }
      return executePipe(input, pipe, info, "string");
    }
  };
}

// src/schemas/string/stringAsync.ts
function stringAsync(arg1, arg2) {
  const [error, pipe] = getDefaultArgs(arg1, arg2);
  return {
    /**
     * The schema type.
     */
    schema: "string",
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async _parse(input, info) {
      if (typeof input !== "string") {
        return getIssues(
          info,
          "type",
          "string",
          error || "Invalid type",
          input
        );
      }
      return executePipeAsync(input, pipe, info, "string");
    }
  };
}

// src/schemas/record/utils/getRecordArgs/getRecordArgs.ts
function getRecordArgs(arg1, arg2, arg3, arg4) {
  if (typeof arg2 === "object" && !Array.isArray(arg2)) {
    const [error2, pipe2] = getDefaultArgs(arg3, arg4);
    return [arg1, arg2, error2, pipe2];
  }
  const [error, pipe] = getDefaultArgs(
    arg2,
    arg3
  );
  return [string(), arg1, error, pipe];
}

// src/schemas/record/values.ts
var BLOCKED_KEYS = ["__proto__", "prototype", "constructor"];

// src/schemas/record/record.ts
function record(arg1, arg2, arg3, arg4) {
  const [key, value2, error, pipe] = getRecordArgs(arg1, arg2, arg3, arg4);
  return {
    /**
     * The schema type.
     */
    schema: "record",
    /**
     * The record key and value schema.
     */
    record: { key, value: value2 },
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (!input || typeof input !== "object") {
        return getIssues(
          info,
          "type",
          "record",
          error || "Invalid type",
          input
        );
      }
      let issues;
      const output = {};
      for (const [inputKey, inputValue] of Object.entries(input)) {
        if (!BLOCKED_KEYS.includes(inputKey)) {
          let pathItem;
          const keyResult = key._parse(inputKey, {
            origin: "key",
            abortEarly: info?.abortEarly,
            abortPipeEarly: info?.abortPipeEarly
          });
          if (keyResult.issues) {
            pathItem = {
              schema: "record",
              input,
              key: inputKey,
              value: inputValue
            };
            for (const issue of keyResult.issues) {
              issue.path = [pathItem];
              issues?.push(issue);
            }
            if (!issues) {
              issues = keyResult.issues;
            }
            if (info?.abortEarly) {
              break;
            }
          }
          const valueResult = value2._parse(inputValue, info);
          if (valueResult.issues) {
            pathItem = pathItem || {
              schema: "record",
              input,
              key: inputKey,
              value: inputValue
            };
            for (const issue of valueResult.issues) {
              if (issue.path) {
                issue.path.unshift(pathItem);
              } else {
                issue.path = [pathItem];
              }
              issues?.push(issue);
            }
            if (!issues) {
              issues = valueResult.issues;
            }
            if (info?.abortEarly) {
              break;
            }
          }
          if (!keyResult.issues && !valueResult.issues) {
            output[keyResult.output] = valueResult.output;
          }
        }
      }
      return issues ? { issues } : executePipe(
        output,
        pipe,
        info,
        "record"
      );
    }
  };
}

// src/schemas/record/recordAsync.ts
function recordAsync(arg1, arg2, arg3, arg4) {
  const [key, value2, error, pipe] = getRecordArgs(arg1, arg2, arg3, arg4);
  return {
    /**
     * The schema type.
     */
    schema: "record",
    /**
     * The record key and value schema.
     */
    record: { key, value: value2 },
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async _parse(input, info) {
      if (!input || typeof input !== "object") {
        return getIssues(
          info,
          "type",
          "record",
          error || "Invalid type",
          input
        );
      }
      let issues;
      const output = {};
      await Promise.all(
        // Note: `Object.entries(...)` converts each key to a string
        Object.entries(input).map(async ([inputKey, inputValue]) => {
          if (!BLOCKED_KEYS.includes(inputKey)) {
            let pathItem;
            const [keyResult, valueResult] = await Promise.all(
              [
                { schema: key, value: inputKey, origin: "key" },
                { schema: value2, value: inputValue, origin: "value" }
              ].map(async ({ schema, value: value3, origin }) => {
                if (!(info?.abortEarly && issues)) {
                  const result = await schema._parse(value3, {
                    origin,
                    abortEarly: info?.abortEarly,
                    abortPipeEarly: info?.abortPipeEarly
                  });
                  if (!(info?.abortEarly && issues)) {
                    if (result.issues) {
                      pathItem = pathItem || {
                        schema: "record",
                        input,
                        key: inputKey,
                        value: inputValue
                      };
                      for (const issue of result.issues) {
                        if (issue.path) {
                          issue.path.unshift(pathItem);
                        } else {
                          issue.path = [pathItem];
                        }
                        issues?.push(issue);
                      }
                      if (!issues) {
                        issues = result.issues;
                      }
                      if (info?.abortEarly) {
                        throw null;
                      }
                    } else {
                      return result;
                    }
                  }
                }
              })
            ).catch(() => []);
            if (keyResult && valueResult) {
              output[keyResult.output] = valueResult.output;
            }
          }
        })
      );
      return issues ? { issues } : executePipeAsync(
        output,
        pipe,
        info,
        "record"
      );
    }
  };
}

// src/schemas/recursive/recursive.ts
function recursive(getter) {
  return {
    /**
     * The schema type.
     */
    schema: "recursive",
    /**
     * The schema getter.
     */
    getter,
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      return getter()._parse(input, info);
    }
  };
}

// src/schemas/recursive/recursiveAsync.ts
function recursiveAsync(getter) {
  return {
    /**
     * The schema type.
     */
    schema: "recursive",
    /**
     * The schema getter.
     */
    getter,
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async _parse(input, info) {
      return getter()._parse(input, info);
    }
  };
}

// src/schemas/set/set.ts
function set(value2, arg2, arg3) {
  const [error, pipe] = getDefaultArgs(arg2, arg3);
  return {
    /**
     * The schema type.
     */
    schema: "set",
    /**
     * The set value schema.
     */
    set: { value: value2 },
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (!(input instanceof Set)) {
        return getIssues(info, "type", "set", error || "Invalid type", input);
      }
      let key = 0;
      let issues;
      const output = /* @__PURE__ */ new Set();
      for (const inputValue of input) {
        const result = value2._parse(inputValue, info);
        if (result.issues) {
          const pathItem = {
            schema: "set",
            input,
            key,
            value: inputValue
          };
          for (const issue of result.issues) {
            if (issue.path) {
              issue.path.unshift(pathItem);
            } else {
              issue.path = [pathItem];
            }
            issues?.push(issue);
          }
          if (!issues) {
            issues = result.issues;
          }
          if (info?.abortEarly) {
            break;
          }
        } else {
          output.add(result.output);
        }
        key++;
      }
      return issues ? { issues } : executePipe(output, pipe, info, "set");
    }
  };
}

// src/schemas/set/setAsync.ts
function setAsync(value2, arg2, arg3) {
  const [error, pipe] = getDefaultArgs(arg2, arg3);
  return {
    /**
     * The schema type.
     */
    schema: "set",
    /**
     * The set value schema.
     */
    set: { value: value2 },
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async _parse(input, info) {
      if (!(input instanceof Set)) {
        return getIssues(info, "type", "set", error || "Invalid type", input);
      }
      let issues;
      const output = /* @__PURE__ */ new Set();
      await Promise.all(
        Array.from(input.values()).map(async (inputValue, key) => {
          if (!(info?.abortEarly && issues)) {
            const result = await value2._parse(inputValue, info);
            if (!(info?.abortEarly && issues)) {
              if (result.issues) {
                const pathItem = {
                  schema: "set",
                  input,
                  key,
                  value: inputValue
                };
                for (const issue of result.issues) {
                  if (issue.path) {
                    issue.path.unshift(pathItem);
                  } else {
                    issue.path = [pathItem];
                  }
                  issues?.push(issue);
                }
                if (!issues) {
                  issues = result.issues;
                }
                if (info?.abortEarly) {
                  throw null;
                }
              } else {
                output.add(result.output);
              }
            }
          }
        })
      ).catch(() => null);
      return issues ? { issues } : executePipeAsync(input, pipe, info, "set");
    }
  };
}

// src/schemas/special/special.ts
function special(check, arg2, arg3) {
  const [error, pipe] = getDefaultArgs(arg2, arg3);
  return {
    /**
     * The schema type.
     */
    schema: "special",
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (!check(input)) {
        return getIssues(
          info,
          "type",
          "special",
          error || "Invalid type",
          input
        );
      }
      return executePipe(input, pipe, info, "special");
    }
  };
}

// src/schemas/special/specialAsync.ts
function specialAsync(check, arg2, arg3) {
  const [error, pipe] = getDefaultArgs(arg2, arg3);
  return {
    /**
     * The schema type.
     */
    schema: "special",
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async _parse(input, info) {
      if (!await check(input)) {
        return getIssues(
          info,
          "type",
          "special",
          error || "Invalid type",
          input
        );
      }
      return executePipeAsync(input, pipe, info, "special");
    }
  };
}

// src/schemas/symbol/symbol.ts
function symbol2(error) {
  return {
    /**
     * The schema type.
     */
    schema: "symbol",
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (typeof input !== "symbol") {
        return getIssues(
          info,
          "type",
          "symbol",
          error || "Invalid type",
          input
        );
      }
      return { output: input };
    }
  };
}

// src/schemas/symbol/symbolAsync.ts
function symbolAsync(error) {
  return {
    /**
     * The schema type.
     */
    schema: "symbol",
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async _parse(input, info) {
      if (typeof input !== "symbol") {
        return getIssues(
          info,
          "type",
          "symbol",
          error || "Invalid type",
          input
        );
      }
      return { output: input };
    }
  };
}

// src/schemas/tuple/utils/getTupleArgs/getTupleArgs.ts
function getTupleArgs(arg1, arg2, arg3) {
  if (typeof arg1 === "object" && !Array.isArray(arg1)) {
    const [error2, pipe2] = getDefaultArgs(arg2, arg3);
    return [arg1, error2, pipe2];
  }
  const [error, pipe] = getDefaultArgs(
    arg1,
    arg2
  );
  return [void 0, error, pipe];
}

// src/schemas/tuple/tuple.ts
function tuple(items, arg2, arg3, arg4) {
  const [rest, error, pipe] = getTupleArgs(arg2, arg3, arg4);
  return {
    /**
     * The schema type.
     */
    schema: "tuple",
    /**
     * The tuple items and rest schema.
     */
    tuple: { items, rest },
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (!Array.isArray(input) || !rest && items.length !== input.length || rest && items.length > input.length) {
        return getIssues(info, "type", "tuple", error || "Invalid type", input);
      }
      let issues;
      const output = [];
      for (let key = 0; key < items.length; key++) {
        const value2 = input[key];
        const result = items[key]._parse(value2, info);
        if (result.issues) {
          const pathItem = {
            schema: "tuple",
            input,
            key,
            value: value2
          };
          for (const issue of result.issues) {
            if (issue.path) {
              issue.path.unshift(pathItem);
            } else {
              issue.path = [pathItem];
            }
            issues?.push(issue);
          }
          if (!issues) {
            issues = result.issues;
          }
          if (info?.abortEarly) {
            break;
          }
        } else {
          output[key] = result.output;
        }
      }
      if (rest) {
        for (let key = items.length; key < input.length; key++) {
          const value2 = input[key];
          const result = rest._parse(value2, info);
          if (result.issues) {
            const pathItem = {
              schema: "tuple",
              input,
              key,
              value: value2
            };
            for (const issue of result.issues) {
              if (issue.path) {
                issue.path.unshift(pathItem);
              } else {
                issue.path = [pathItem];
              }
              issues?.push(issue);
            }
            if (!issues) {
              issues = result.issues;
            }
            if (info?.abortEarly) {
              break;
            }
          } else {
            output[key] = result.output;
          }
        }
      }
      return issues ? { issues } : executePipe(
        output,
        pipe,
        info,
        "tuple"
      );
    }
  };
}

// src/schemas/tuple/tupleAsync.ts
function tupleAsync(items, arg2, arg3, arg4) {
  const [rest, error, pipe] = getTupleArgs(arg2, arg3, arg4);
  return {
    /**
     * The schema type.
     */
    schema: "tuple",
    /**
     * The tuple items and rest schema.
     */
    tuple: { items, rest },
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async _parse(input, info) {
      if (!Array.isArray(input) || !rest && items.length !== input.length || rest && items.length > input.length) {
        return getIssues(info, "type", "tuple", error || "Invalid type", input);
      }
      let issues;
      const output = [];
      await Promise.all([
        // Parse schema of each tuple item
        Promise.all(
          items.map(async (schema, key) => {
            if (!(info?.abortEarly && issues)) {
              const value2 = input[key];
              const result = await schema._parse(value2, info);
              if (!(info?.abortEarly && issues)) {
                if (result.issues) {
                  const pathItem = {
                    schema: "tuple",
                    input,
                    key,
                    value: value2
                  };
                  for (const issue of result.issues) {
                    if (issue.path) {
                      issue.path.unshift(pathItem);
                    } else {
                      issue.path = [pathItem];
                    }
                    issues?.push(issue);
                  }
                  if (!issues) {
                    issues = result.issues;
                  }
                  if (info?.abortEarly) {
                    throw null;
                  }
                } else {
                  output[key] = result.output;
                }
              }
            }
          })
        ),
        // If necessary parse schema of each rest item
        rest && Promise.all(
          input.slice(items.length).map(async (value2, index) => {
            if (!(info?.abortEarly && issues)) {
              const key = items.length + index;
              const result = await rest._parse(value2, info);
              if (!(info?.abortEarly && issues)) {
                if (result.issues) {
                  const pathItem = {
                    schema: "tuple",
                    input,
                    key,
                    value: value2
                  };
                  for (const issue of result.issues) {
                    if (issue.path) {
                      issue.path.unshift(pathItem);
                    } else {
                      issue.path = [pathItem];
                    }
                    issues?.push(issue);
                  }
                  if (!issues) {
                    issues = result.issues;
                  }
                  if (info?.abortEarly) {
                    throw null;
                  }
                } else {
                  output[key] = result.output;
                }
              }
            }
          })
        )
      ]).catch(() => null);
      return issues ? { issues } : executePipeAsync(
        output,
        pipe,
        info,
        "tuple"
      );
    }
  };
}

// src/schemas/undefinedType/undefinedType.ts
function undefinedType(error) {
  return {
    /**
     * The schema type.
     */
    schema: "undefined",
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (typeof input !== "undefined") {
        return getIssues(
          info,
          "type",
          "undefined",
          error || "Invalid type",
          input
        );
      }
      return { output: input };
    }
  };
}

// src/schemas/undefinedType/undefinedTypeAsync.ts
function undefinedTypeAsync(error) {
  return {
    /**
     * The schema type.
     */
    schema: "undefined",
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async _parse(input, info) {
      if (typeof input !== "undefined") {
        return getIssues(
          info,
          "type",
          "undefined",
          error || "Invalid type",
          input
        );
      }
      return { output: input };
    }
  };
}

// src/schemas/union/union.ts
function union(union2, error) {
  return {
    /**
     * The schema type.
     */
    schema: "union",
    /**
     * The union schema.
     */
    union: union2,
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      let issues;
      let output;
      for (const schema of union2) {
        const result = schema._parse(input, info);
        if (result.issues) {
          if (issues) {
            for (const issue of result.issues) {
              issues.push(issue);
            }
          } else {
            issues = result.issues;
          }
        } else {
          output = [result.output];
          break;
        }
      }
      return output ? { output: output[0] } : getIssues(
        info,
        "type",
        "union",
        error || "Invalid type",
        input,
        issues
      );
    }
  };
}

// src/schemas/union/unionAsync.ts
function unionAsync(union2, error) {
  return {
    /**
     * The schema type.
     */
    schema: "union",
    /**
     * The union schema.
     */
    union: union2,
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async _parse(input, info) {
      let issues;
      let output;
      for (const schema of union2) {
        const result = await schema._parse(input, info);
        if (result.issues) {
          if (issues) {
            for (const issue of result.issues) {
              issues.push(issue);
            }
          } else {
            issues = result.issues;
          }
        } else {
          output = [result.output];
          break;
        }
      }
      return output ? { output: output[0] } : getIssues(
        info,
        "type",
        "union",
        error || "Invalid type",
        input,
        issues
      );
    }
  };
}

// src/schemas/unknown/unknown.ts
function unknown(pipe = []) {
  return {
    /**
     * The schema type.
     */
    schema: "unknown",
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      return executePipe(input, pipe, info, "unknown");
    }
  };
}

// src/schemas/unknown/unknownAsync.ts
function unknownAsync(pipe = []) {
  return {
    /**
     * The schema type.
     */
    schema: "unknown",
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async _parse(input, info) {
      return executePipeAsync(input, pipe, info, "unknown");
    }
  };
}

// src/schemas/voidType/voidType.ts
function voidType(error) {
  return {
    /**
     * The schema type.
     */
    schema: "void",
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (typeof input !== "undefined") {
        return getIssues(info, "type", "void", error || "Invalid type", input);
      }
      return { output: input };
    }
  };
}

// src/schemas/voidType/voidTypeAsync.ts
function voidTypeAsync(error) {
  return {
    /**
     * The schema type.
     */
    schema: "void",
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async _parse(input, info) {
      if (typeof input !== "undefined") {
        return getIssues(info, "type", "void", error || "Invalid type", input);
      }
      return { output: input };
    }
  };
}

// src/methods/keyof/keyof.ts
function keyof(schema) {
  return enumType(
    Object.keys(schema.object)
  );
}

// src/methods/merge/merge.ts
function merge(schemas, arg2, arg3) {
  const [error, pipe] = getDefaultArgs(arg2, arg3);
  return object(
    schemas.reduce(
      (object2, schemas2) => ({ ...object2, ...schemas2.object }),
      {}
    ),
    error,
    pipe
  );
}

// src/methods/merge/mergeAsync.ts
function mergeAsync(schemas, arg2, arg3) {
  const [error, pipe] = getDefaultArgs(arg2, arg3);
  return objectAsync(
    schemas.reduce(
      (object2, schemas2) => ({ ...object2, ...schemas2.object }),
      {}
    ),
    error,
    pipe
  );
}

// src/methods/omit/omit.ts
function omit(schema, keys, arg3, arg4) {
  const [error, pipe] = getDefaultArgs(arg3, arg4);
  return object(
    Object.entries(schema.object).reduce(
      (object2, [key, schema2]) => keys.includes(key) ? object2 : { ...object2, [key]: schema2 },
      {}
    ),
    error,
    pipe
  );
}

// src/methods/omit/omitAsync.ts
function omitAsync(schema, keys, arg3, arg4) {
  const [error, pipe] = getDefaultArgs(arg3, arg4);
  return objectAsync(
    Object.entries(schema.object).reduce(
      (object2, [key, schema2]) => keys.includes(key) ? object2 : { ...object2, [key]: schema2 },
      {}
    ),
    error,
    pipe
  );
}

// src/methods/parse/parse.ts
function parse(schema, input, info) {
  const result = schema._parse(input, info);
  if (result.issues) {
    throw new ValiError(result.issues);
  }
  return result.output;
}

// src/methods/parse/parseAsync.ts
async function parseAsync(schema, input, info) {
  const result = await schema._parse(input, info);
  if (result.issues) {
    throw new ValiError(result.issues);
  }
  return result.output;
}

// src/methods/partial/partial.ts
function partial(schema, arg3, arg4) {
  const [error, pipe] = getDefaultArgs(arg3, arg4);
  return object(
    Object.entries(schema.object).reduce(
      (object2, [key, schema2]) => ({
        ...object2,
        [key]: optional(schema2)
      }),
      {}
    ),
    error,
    // @ts-ignore FIXME: Remove line once bug in TS is fixed
    pipe
  );
}

// src/methods/partial/partialAsync.ts
function partialAsync(schema, arg3, arg4) {
  const [error, pipe] = getDefaultArgs(arg3, arg4);
  return objectAsync(
    Object.entries(schema.object).reduce(
      (object2, [key, schema2]) => ({
        ...object2,
        [key]: optionalAsync(schema2)
      }),
      {}
    ),
    error,
    // @ts-ignore FIXME: Remove line once bug in TS is fixed
    pipe
  );
}

// src/methods/pick/pick.ts
function pick(schema, keys, arg3, arg4) {
  const [error, pipe] = getDefaultArgs(arg3, arg4);
  return object(
    Object.entries(schema.object).reduce(
      (object2, [key, schema2]) => keys.includes(key) ? { ...object2, [key]: schema2 } : object2,
      {}
    ),
    error,
    pipe
  );
}

// src/methods/pick/pickAsync.ts
function pickAsync(schema, keys, arg3, arg4) {
  const [error, pipe] = getDefaultArgs(arg3, arg4);
  return objectAsync(
    Object.entries(schema.object).reduce(
      (object2, [key, schema2]) => keys.includes(key) ? { ...object2, [key]: schema2 } : object2,
      {}
    ),
    error,
    pipe
  );
}

// src/methods/required/required.ts
function required(schema, arg3, arg4) {
  const [error, pipe] = getDefaultArgs(arg3, arg4);
  return object(
    Object.entries(schema.object).reduce(
      (object2, [key, schema2]) => ({
        ...object2,
        [key]: nonOptional(schema2)
      }),
      {}
    ),
    error,
    // @ts-ignore FIXME: Remove line once bug in TS is fixed
    pipe
  );
}

// src/methods/required/requiredAsync.ts
function requiredAsync(schema, arg3, arg4) {
  const [error, pipe] = getDefaultArgs(arg3, arg4);
  return objectAsync(
    Object.entries(schema.object).reduce(
      (object2, [key, schema2]) => ({
        ...object2,
        [key]: nonOptionalAsync(schema2)
      }),
      {}
    ),
    error,
    // @ts-ignore FIXME: Remove line once bug in TS is fixed
    pipe
  );
}

// src/methods/safeParse/safeParse.ts
function safeParse(schema, input, info) {
  const result = schema._parse(input, info);
  return result.issues ? {
    success: false,
    error: new ValiError(result.issues),
    issues: result.issues
  } : {
    success: true,
    data: result.output,
    output: result.output
  };
}

// src/methods/safeParse/safeParseAsync.ts
async function safeParseAsync(schema, input, info) {
  const result = await schema._parse(input, info);
  return result.issues ? {
    success: false,
    error: new ValiError(result.issues),
    issues: result.issues
  } : {
    success: true,
    data: result.output,
    output: result.output
  };
}

// src/methods/strict/strict.ts
function strict(schema, error) {
  return {
    ...schema,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      const result = schema._parse(input, info);
      return !result.issues && // Check length of input and output keys
      Object.keys(input).length !== Object.keys(result.output).length ? getIssues(info, "object", "strict", error || "Invalid keys", input) : result;
    }
  };
}

// src/methods/strict/strictAsync.ts
function strictAsync(schema, error) {
  return {
    ...schema,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async _parse(input, info) {
      const result = await schema._parse(input, info);
      return !result.issues && // Check length of input and output keys
      Object.keys(input).length !== Object.keys(result.output).length ? getIssues(info, "object", "strict", error || "Invalid keys", input) : result;
    }
  };
}

// src/methods/transform/transform.ts
function transform(schema, action) {
  return {
    ...schema,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      const result = schema._parse(input, info);
      return result.issues ? result : { output: action(result.output) };
    }
  };
}

// src/methods/transform/transformAsync.ts
function transformAsync(schema, action) {
  return {
    ...schema,
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async _parse(input, info) {
      const result = await schema._parse(input, info);
      return result.issues ? result : { output: await action(result.output) };
    }
  };
}

// src/methods/unwrap/unwrap.ts
function unwrap(schema) {
  return schema.wrapped;
}

// src/methods/withDefault/withDefault.ts
function withDefault(schema, value2) {
  return {
    ...schema,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      return schema._parse(
        input === void 0 ? typeof value2 === "function" ? value2() : value2 : input,
        info
      );
    }
  };
}
var useDefault = withDefault;

// src/transformations/toCustom/toCustom.ts
function toCustom(action) {
  return (input) => ({ output: action(input) });
}

// src/transformations/toCustom/toCustomAsync.ts
function toCustomAsync(action) {
  return async (input) => ({
    output: await action(input)
  });
}

// src/transformations/toLowerCase/toLowerCase.ts
function toLowerCase() {
  return (input) => ({
    output: input.toLocaleLowerCase()
  });
}

// src/transformations/toMaxValue/toMaxValue.ts
function toMaxValue(requirement) {
  return (input) => ({
    output: input > requirement ? requirement : input
  });
}

// src/transformations/toMinValue/toMinValue.ts
function toMinValue(requirement) {
  return (input) => ({
    output: input < requirement ? requirement : input
  });
}

// src/transformations/toTrimmed/toTrimmed.ts
function toTrimmed() {
  return (input) => ({ output: input.trim() });
}

// src/transformations/toTrimmedEnd/toTrimmedEnd.ts
function toTrimmedEnd() {
  return (input) => ({ output: input.trimEnd() });
}

// src/transformations/toTrimmedStart/toTrimmedStart.ts
function toTrimmedStart() {
  return (input) => ({
    output: input.trimStart()
  });
}

// src/transformations/toUpperCase/toUpperCase.ts
function toUpperCase() {
  return (input) => ({
    output: input.toUpperCase()
  });
}

// src/validations/bytes/bytes.ts
function bytes(requirement, error) {
  return (input) => {
    if (new TextEncoder().encode(input).length !== requirement) {
      return {
        issue: {
          validation: "bytes",
          message: error || "Invalid byte length",
          input
        }
      };
    }
    return { output: input };
  };
}

// src/validations/custom/custom.ts
function custom(requirement, error) {
  return (input) => {
    if (!requirement(input)) {
      return {
        issue: {
          validation: "custom",
          message: error || "Invalid input",
          input
        }
      };
    }
    return { output: input };
  };
}

// src/validations/custom/customAsync.ts
function customAsync(requirement, error) {
  return async (input) => {
    if (!await requirement(input)) {
      return {
        issue: {
          validation: "custom",
          message: error || "Invalid input",
          input
        }
      };
    }
    return { output: input };
  };
}

// src/validations/email/email.ts
function email(error) {
  return (input) => {
    if (!/^(([^<>()[\].,;:\s@"]+(\.[^<>()[\].,;:\s@"]+)*)|(".+"))@(([^<>()[\].,;:\s@"]+\.)+[^<>()[\].,;:\s@"]{2,})$/i.test(
      input
    )) {
      return {
        issue: {
          validation: "email",
          message: error || "Invalid email",
          input
        }
      };
    }
    return { output: input };
  };
}

// src/validations/emoji/emoji.ts
function emoji(error) {
  return (input) => {
    if (!/^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/u.test(input)) {
      return {
        issue: {
          validation: "emoji",
          message: error || "Invalid emoji",
          input
        }
      };
    }
    return { output: input };
  };
}

// src/validations/endsWith/endsWith.ts
function endsWith(requirement, error) {
  return (input) => {
    if (!input.endsWith(requirement)) {
      return {
        issue: {
          validation: "ends_with",
          message: error || "Invalid end",
          input
        }
      };
    }
    return { output: input };
  };
}

// src/validations/equal/equal.ts
function equal(requirement, error) {
  return (input) => {
    if (input !== requirement) {
      return {
        issue: {
          validation: "equal",
          message: error || "Invalid input",
          input
        }
      };
    }
    return { output: input };
  };
}

// src/validations/excludes/excludes.ts
function excludes(requirement, error) {
  return (input) => {
    if (input.includes(requirement)) {
      return {
        issue: {
          validation: "excludes",
          message: error || "Invalid content",
          input
        }
      };
    }
    return { output: input };
  };
}

// src/validations/finite/finite.ts
function finite(error) {
  return (input) => {
    if (!Number.isFinite(input)) {
      return {
        issue: {
          validation: "finite",
          message: error || "Invalid finite number",
          input
        }
      };
    }
    return { output: input };
  };
}

// src/validations/imei/imei.ts
function imei(error) {
  return (input) => {
    if (!/^\d{2}[ |/|-]?\d{6}[ |/|-]?\d{6}[ |/|-]?\d$/.test(input) || !isLuhnAlgo(input)) {
      return {
        issue: {
          validation: "imei",
          message: error || "Invalid IMEI",
          input
        }
      };
    }
    return { output: input };
  };
}

// src/validations/includes/includes.ts
function includes(requirement, error) {
  return (input) => {
    if (!input.includes(requirement)) {
      return {
        issue: {
          validation: "includes",
          message: error || "Invalid content",
          input
        }
      };
    }
    return { output: input };
  };
}

// src/validations/integer/integer.ts
function integer(error) {
  return (input) => {
    if (!Number.isInteger(input)) {
      return {
        issue: {
          validation: "integer",
          message: error || "Invalid integer",
          input
        }
      };
    }
    return { output: input };
  };
}

// src/validations/ip/ip.ts
function ip(error) {
  return (input) => {
    if (!/^((25[0-5]|(2[0-4]|1\d|[1-9]|)\d)\.?\b){4}$/.test(input) && !/^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/.test(
      input
    )) {
      return {
        issue: {
          validation: "ip",
          message: error || "Invalid IP",
          input
        }
      };
    }
    return { output: input };
  };
}

// src/validations/ipv4/ipv4.ts
function ipv4(error) {
  return (input) => {
    if (!/^((25[0-5]|(2[0-4]|1\d|[1-9]|)\d)\.?\b){4}$/.test(input)) {
      return {
        issue: {
          validation: "ipv4",
          message: error || "Invalid IP v4",
          input
        }
      };
    }
    return { output: input };
  };
}

// src/validations/ipv6/ipv6.ts
function ipv6(error) {
  return (input) => {
    if (!/^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/.test(
      input
    )) {
      return {
        issue: {
          validation: "ipv6",
          message: error || "Invalid IP v6",
          input
        }
      };
    }
    return { output: input };
  };
}

// src/validations/isoDate/isoDate.ts
function isoDate(error) {
  return (input) => {
    if (!/^\d{4}-(0[1-9]|1[0-2])-([12]\d|0[1-9]|3[01])$/.test(input)) {
      return {
        issue: {
          validation: "iso_date",
          message: error || "Invalid date",
          input
        }
      };
    }
    return { output: input };
  };
}

// src/validations/isoDateTime/isoDateTime.ts
function isoDateTime(error) {
  return (input) => {
    if (!/^\d{4}-(0[1-9]|1[0-2])-([12]\d|0[1-9]|3[01])T(0[0-9]|1\d|2[0-3]):[0-5]\d$/.test(
      input
    )) {
      return {
        issue: {
          validation: "iso_date_time",
          message: error || "Invalid datetime",
          input
        }
      };
    }
    return { output: input };
  };
}

// src/validations/isoTime/isoTime.ts
function isoTime(error) {
  return (input) => {
    if (!/^(0[0-9]|1\d|2[0-3]):[0-5]\d$/.test(input)) {
      return {
        issue: {
          validation: "iso_time",
          message: error || "Invalid time",
          input
        }
      };
    }
    return { output: input };
  };
}

// src/validations/isoTimeSecond/isoTimeSecond.ts
function isoTimeSecond(error) {
  return (input) => {
    if (!/^(0[0-9]|1\d|2[0-3]):[0-5]\d:[0-5]\d$/.test(input)) {
      return {
        issue: {
          validation: "iso_time_second",
          message: error || "Invalid time",
          input
        }
      };
    }
    return { output: input };
  };
}

// src/validations/isoTimestamp/isoTimestamp.ts
function isoTimestamp(error) {
  return (input) => {
    if (!/^\d{4}-(0[1-9]|1[0-2])-([12]\d|0[1-9]|3[01])T(0[0-9]|1\d|2[0-3]):[0-5]\d:[0-5]\d\.\d{3}Z$/.test(
      input
    )) {
      return {
        issue: {
          validation: "iso_timestamp",
          message: error || "Invalid timestamp",
          input
        }
      };
    }
    return { output: input };
  };
}

// src/validations/isoWeek/isoWeek.ts
function isoWeek(error) {
  return (input) => {
    if (!/^\d{4}-W(0[1-9]|[1-4]\d|5[0-3])$/.test(input)) {
      return {
        issue: {
          validation: "iso_week",
          message: error || "Invalid week",
          input
        }
      };
    }
    return { output: input };
  };
}

// src/validations/length/length.ts
function length(requirement, error) {
  return (input) => {
    if (input.length !== requirement) {
      return {
        issue: {
          validation: "length",
          message: error || "Invalid length",
          input
        }
      };
    }
    return { output: input };
  };
}

// src/validations/maxBytes/maxBytes.ts
function maxBytes(requirement, error) {
  return (input) => {
    if (new TextEncoder().encode(input).length > requirement) {
      return {
        issue: {
          validation: "max_bytes",
          message: error || "Invalid byte length",
          input
        }
      };
    }
    return { output: input };
  };
}

// src/validations/maxLength/maxLength.ts
function maxLength(requirement, error) {
  return (input) => {
    if (input.length > requirement) {
      return {
        issue: {
          validation: "max_length",
          message: error || "Invalid length",
          input
        }
      };
    }
    return { output: input };
  };
}

// src/validations/maxSize/maxSize.ts
function maxSize(requirement, error) {
  return (input) => {
    if (input.size > requirement) {
      return {
        issue: {
          validation: "max_size",
          message: error || "Invalid size",
          input
        }
      };
    }
    return { output: input };
  };
}

// src/validations/maxValue/maxValue.ts
function maxValue(requirement, error) {
  return (input) => {
    if (input > requirement) {
      return {
        issue: {
          validation: "max_value",
          message: error || "Invalid value",
          input
        }
      };
    }
    return { output: input };
  };
}
var maxRange = maxValue;

// src/validations/minBytes/minBytes.ts
function minBytes(requirement, error) {
  return (input) => {
    if (new TextEncoder().encode(input).length < requirement) {
      return {
        issue: {
          validation: "min_bytes",
          message: error || "Invalid byte length",
          input
        }
      };
    }
    return { output: input };
  };
}

// src/validations/mimeType/mimeType.ts
function mimeType(requirement, error) {
  return (input) => {
    if (!requirement.includes(input.type)) {
      return {
        issue: {
          validation: "mime_type",
          message: error || "Invalid MIME type",
          input
        }
      };
    }
    return { output: input };
  };
}

// src/validations/minLength/minLength.ts
function minLength(requirement, error) {
  return (input) => {
    if (input.length < requirement) {
      return {
        issue: {
          validation: "min_length",
          message: error || "Invalid length",
          input
        }
      };
    }
    return { output: input };
  };
}

// src/validations/minSize/minSize.ts
function minSize(requirement, error) {
  return (input) => {
    if (input.size < requirement) {
      return {
        issue: {
          validation: "min_size",
          message: error || "Invalid size",
          input
        }
      };
    }
    return { output: input };
  };
}

// src/validations/minValue/minValue.ts
function minValue(requirement, error) {
  return (input) => {
    if (input < requirement) {
      return {
        issue: {
          validation: "min_value",
          message: error || "Invalid value",
          input
        }
      };
    }
    return { output: input };
  };
}
var minRange = minValue;

// src/validations/multipleOf/multipleOf.ts
function multipleOf(requirement, error) {
  return (input) => {
    if (input % requirement !== 0) {
      return {
        issue: {
          validation: "multipleOf",
          message: error || "Invalid multiple",
          input
        }
      };
    }
    return { output: input };
  };
}

// src/validations/regex/regex.ts
function regex(requirement, error) {
  return (input) => {
    if (!requirement.test(input)) {
      return {
        issue: {
          validation: "regex",
          message: error || "Invalid regex",
          input
        }
      };
    }
    return { output: input };
  };
}

// src/validations/safeInteger/safeInteger.ts
function safeInteger(error) {
  return (input) => {
    if (!Number.isSafeInteger(input)) {
      return {
        issue: {
          validation: "safe_integer",
          message: error || "Invalid safe integer",
          input
        }
      };
    }
    return { output: input };
  };
}

// src/validations/size/size.ts
function size(requirement, error) {
  return (input) => {
    if (input.size !== requirement) {
      return {
        issue: {
          validation: "size",
          message: error || "Invalid size",
          input
        }
      };
    }
    return { output: input };
  };
}

// src/validations/startsWith/startsWith.ts
function startsWith(requirement, error) {
  return (input) => {
    if (!input.startsWith(requirement)) {
      return {
        issue: {
          validation: "starts_with",
          message: error || "Invalid start",
          input
        }
      };
    }
    return { output: input };
  };
}

// src/validations/url/url.ts
function url(error) {
  return (input) => {
    try {
      new URL(input);
      return { output: input };
    } catch (_) {
      return {
        issue: {
          validation: "url",
          message: error || "Invalid URL",
          input
        }
      };
    }
  };
}

// src/validations/uuid/uuid.ts
function uuid(error) {
  return (input) => {
    if (!/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(
      input
    )) {
      return {
        issue: {
          validation: "uuid",
          message: error || "Invalid UUID",
          input
        }
      };
    }
    return { output: input };
  };
}

// src/validations/value/value.ts
function value(requirement, error) {
  return (input) => {
    if (input !== requirement) {
      return {
        issue: {
          validation: "value",
          message: error || "Invalid value",
          input
        }
      };
    }
    return { output: input };
  };
}
export {
  ValiError,
  any,
  anyAsync,
  array,
  arrayAsync,
  bigint,
  bigintAsync,
  blob,
  blobAsync,
  boolean,
  booleanAsync,
  brand,
  bytes,
  coerce,
  coerceAsync,
  custom,
  customAsync,
  date,
  dateAsync,
  email,
  emoji,
  endsWith,
  enumType,
  enumTypeAsync,
  equal,
  excludes,
  executePipe,
  executePipeAsync,
  fallback,
  fallbackAsync,
  finite,
  flatten,
  getDefaultArgs,
  getIssues,
  imei,
  includes,
  instance,
  instanceAsync,
  integer,
  ip,
  ipv4,
  ipv6,
  is,
  isLuhnAlgo,
  isoDate,
  isoDateTime,
  isoTime,
  isoTimeSecond,
  isoTimestamp,
  isoWeek,
  keyof,
  length,
  literal,
  literalAsync,
  map,
  mapAsync,
  maxBytes,
  maxLength,
  maxRange,
  maxSize,
  maxValue,
  merge,
  mergeAsync,
  mimeType,
  minBytes,
  minLength,
  minRange,
  minSize,
  minValue,
  multipleOf,
  nan,
  nanAsync,
  nativeEnum,
  nativeEnumAsync,
  never,
  neverAsync,
  nonNullable,
  nonNullableAsync,
  nonNullish,
  nonNullishAsync,
  nonOptional,
  nonOptionalAsync,
  nullType,
  nullTypeAsync,
  nullable,
  nullableAsync,
  nullish,
  nullishAsync,
  number,
  numberAsync,
  object,
  objectAsync,
  omit,
  omitAsync,
  optional,
  optionalAsync,
  parse,
  parseAsync,
  partial,
  partialAsync,
  pick,
  pickAsync,
  record,
  recordAsync,
  recursive,
  recursiveAsync,
  regex,
  required,
  requiredAsync,
  safeInteger,
  safeParse,
  safeParseAsync,
  set,
  setAsync,
  size,
  special,
  specialAsync,
  startsWith,
  strict,
  strictAsync,
  string,
  stringAsync,
  symbol2 as symbol,
  symbolAsync,
  toCustom,
  toCustomAsync,
  toLowerCase,
  toMaxValue,
  toMinValue,
  toTrimmed,
  toTrimmedEnd,
  toTrimmedStart,
  toUpperCase,
  transform,
  transformAsync,
  tuple,
  tupleAsync,
  undefinedType,
  undefinedTypeAsync,
  union,
  unionAsync,
  unknown,
  unknownAsync,
  unwrap,
  url,
  useDefault,
  uuid,
  value,
  voidType,
  voidTypeAsync,
  withDefault
};
